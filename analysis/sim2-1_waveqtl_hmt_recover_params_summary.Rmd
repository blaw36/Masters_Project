---
title: "WaveQTL with HMT - Simulation 2.1 - Wrap-up of the algorithm correctness simulations"
author: "Brendan Law"
date: "22/07/2019"
output: html_document
---

```{r setup, include=FALSE}
# Clear environment and do some fresh simulations
rm(list = ls());gc();cat("\014");
knitr::opts_chunk$set(echo = TRUE)

# RUN SIMS OR LOAD DATA?
run_sims = F
# SAVE DATA?
overwrite_data = T
save_sims = T

source("../code/WaveQTL/waveqtl_hmt_test_calc_sumlog_func.R")
source("../code/sim2_script.R")
library(data.table)

get_gamma_transition_props <- function(eps_no_scale_data, tying_grp_vect, n_pheno){
  gamma_and_parent <- matrix(c(eps_no_scale_data[get_parent_indices(1:(n_pheno-1))],eps_no_scale_data)
                             , nrow = 2, ncol = (n_pheno-1)
                             , byrow = T)
  gamma_and_parent_dt <- as.data.table(t(gamma_and_parent))
  setnames(gamma_and_parent_dt,names(gamma_and_parent_dt),c("Parent","Child"))
  gamma_and_parent_dt[,"Transition" := paste0(Child,Parent)]
  gamma_and_parent_dt[,"TreeLvl" := findInterval(.I + 1,tying_grp_vect[-1])]
  
  # Exclude the root
  gamma_and_parent_dt <- copy(gamma_and_parent_dt[-1])
  gamma_and_parent_stats <- dcast.data.table(
    gamma_and_parent_dt[,.N,by = .(Transition,TreeLvl)]
    ,formula = TreeLvl ~ Transition
    ,value.var = "N"
    ,fill = 0
  )
  
  transitions_not_there <- setdiff(c("11","01","10","00"),names(gamma_and_parent_stats))
  if(length(transitions_not_there) > 0){
    for(col in transitions_not_there){
      gamma_and_parent_stats[,(col) := 0]
    }
  }
  
  gamma_and_parent_stats[,"Total" := apply(.SD,1,sum),.SDcols = 2:5]
  return(gamma_and_parent_stats[])
}
```
## Overview

The goal here is to finally put a line under the simulation 2 process (and what a long process it was!), and to document a few things we learned along the away regarding:

- When the simulation did/didn't work
- Why it did/didn't work
- What I plan on putting in the thesis
- Extra technical justifications (related to Bayes Factors) for why things went awry, regarding epsilon convergence upon estimation through tying.

In all our markdowns, we can summarise the following work was done:

- Sim 2.0.0: Ran one version of simulation with particular settings. Results weren't great.
- Sim 2.0.1: Attempted many different parameter settings, results weren't great. Observed that tying definitely helps stabilise the variance in estimates (especially at the top of the tree). Also see that a lot of epsilons are moving towards 0 or 1 quite quickly, despite 'empirical' epsilon not being quite so extreme. Especially cases of 0.5/0.5, 0.7/0.3, for example.
- Sim 2.0.2: Same as 2.0.1, just running more experiments. No real learning done.
- Sim 2.0.3: Tried to adjust initial values, trying to shed some light on how there could be such a high log-likelihood for, effectively, random initial parameters. Seeing if altering the parameters would change the log-likelihood it converges to - will it find a better local max with initial values closer to the true empiricals observed? Not really.
- Sim 2.0.4: Where we figured out that really low beta (relative to the noise coefficient) created logBFs which weren't so extreme (more like (1,0) vs (20,0)), which definitely helped out our simulations. We obtained more realistic epsilons here which didn't run away to 1 or 0. '0.7/0.3 - same noise, low beta' is a novel case here.
- A key piece of work we did was around analysing the sensitivty of simulation results to beta. That can be found here: "/code/sim2_20190715_beta_sens_07_03"
- Sim 2.0.5: Running it through the WaveQTL_HMT R script version now, for greater control and customisability, and more interactive debugging. The idea here was to ignore the logBF values being generated by the data, but just to run experiments over how the algorithm parameterises different logBF inputs. This gives us a feel for how it responds to logBFs of different sizes. Key point here was that we need a strong 'null' signal, in conjunction with a strong non-null signal, to prevent estimates frmo converging to the 0/1 extremes.

## When the simulation did/didn't work

- Define: 
  
  + Input epsilon: epsilon we generate data with. It's the epsilon we aim to retrieve.
  + Empirical epsilon: epsilon proportions that come out of the simulated data. Should be somewhat close to (but not exactly equal to) the input epsilons. Ideally, our algorithm will be able to retrieve this set on any one simulation, as it can only do as much as the simulated data it is presented with.
  + Estimated epsilon: the output epsilon parameters from our algorithm, for any given input simulation dataset.
  
- Didn't work with relatively large beta to noise ratio (eg: beta = 2, noise = 0.5), as the signals here were too strong. The output logBFs were in the vicinity of 38 to 42 when there was signal ($\gamma = 1$), and around -1 to 2 otherwise.
- Did work when we significantly reduced the beta to noise ratio (eg: beta = 0.1, noise = 5), as the signals here were not too strong. The output logBFs were in the vicinity of 0 to 2 when there was signal ($\gamma = 1$), and around -1 to 2 otherwise.
- Did some sensitivity analysis on simulations of different betas, and showed that it was quite sensitive to this ratio, and generally only working at lower ratios. Once the ratio got too high (eg: beta = 1.5, noise = 5), then we would see a very fast, and confident (low variability) parameterisation of epsilon = 1. Once the ratio got too low (eg: beta = 0.1, noise = 5), fairly variable parameterisation, but around the epsilon = 0 regions (just classes everything as 0 -- no signal).
- Given that our logBFs were so disparate, we decided to run simulations based on the logBFs themselves to get a better sense of how our algorithms perform with logBFs of different magnitudes, or where the difference in logBF magnitude between signal and noise changes.
- Found that logBF of (1,0) wasn't sufficient to steer our simulation away from the inevitable 0,1 convergence either. logBF of (1,-1) was a lot better for this. But even better was (5,-5), with the estimated epsilon being very close to the empirical epsilons in almost all cases. Larger the disparity, and strength of the null and non-null signal helped steer our algorithm away from just going to the 0/1 situation.
- In fact, in the logBF (1,0) situation, where NO tying was done at all (parameterised values are equal to the value obtained in the one data point), we actually get the case where $\epsilon^{0j}$ stays at the initial value, but $\epsilon^{1j}$ continues to increase. Consequently, posterior probabilities of the cases where $\gamma = 0$ stays at the initial value, whilst posteriors of cases where $\gamma = 1$ goes up to 1. It doesn't actually move down, whereas the gamma = 1 cases have their posterior probabilities increase steadily with each iteration.
- This is almost a 'turning point' logBF situation where we don't have enough 'null' signal to actually move the posterior probabilities for $\gamma = 0$ states beyond their initial values. 'Non-null' signals are recognised, but 'null' signals are not.
- Found that logBF of (20,-1) still wasn't sufficient. Ie a strong non-null signal, but a fairly weak null signal mean that the strong signal still overpowered, and led to tied estimates which moved to the 0/1 situation.


## Why the simulation did/didn't work
- The 0/1 situation is a symptom of strong signals increasing the posterior probability (both the marginal posterior of a given wavelet coefficient, as well as the joint posterior of a parent-child combination) very quickly. Note that these are often correct movements towards the true underlying states (ie for $\gamma = 1$ cases, the posterior of $\gamma_{sl} = 1$ increases to 1 very quickly, and where a transition is made from 0 to 1, the posterior of $\gamma_{sl} = 1,\gamma_{p(sl)} = 0 increases to 1 very quickly).
- However, if the signal for the 'null' cases are not very strong, these will not decrease the posteriors by a lot, or anywhere near as quickly as the posteriors where there is a strong non-null signal.
- In cases where we tie, we average across the posteriors in a given level. If there are similar numbers of, or slightly more, transitions to or from state 1, then these posteriors will dominate, and push the average up, as they rise to 1 quicker. This pushes our estimates up, further and further until it converges at 1.
- In cases where there are significantly more transitions to state 0, then the opposite will happen, and we will get some sort of convergence at 0. So in cases where the 'null' signal is not strong enough, it comes down to the weight of the transitions to determine which way it goes?
- Note that this doesn't happen when no tying is done (ie each parameter is estimated individually), showing how tying here causes the upward drift of the parameterised epsilon, should the null signal be too weak.
- So why were we getting funny results from our simulated data? Because our simulated data shows strong non-null signals (0 all the way to 40, as we have seen), but the null signals are not strong (-1 to 2), and they don't hit the -20 or -40 region to 'balance' against the strong signals.
- This is due to how the logBFs have been generated from the code, and the Servin and Stephens methodology. It's something to do with the fact that: 'current suggested "default" procedure is to average BFs computed with sigma prior parameter = {0.05, 0.1, 0.2, 0.4}, which places more weight on smaller effect sizes, and less weight on overdominance' (see the discussion part of SS for details). Hence, even small noise signals are still possibly recognised as a fair chance to be signal (they'd need to be really really small, relative to the noise, to not be a signal)?
- I think this explains why the beta-noise ratio needs to be so small.

## What's going in the thesis

## Global specs
```{r}
p_n_ind = 70 # 70 individual sample
p_n_pheno = 128 # 128 node tree
p_tying_grp = c(1,2,3,65) # Individuals; scaling coefficient, head of tree. Tying: 3 - 64, 65 - 128
p_param_pi_00 = 0 # Scaling coeff
p_param_pi_11 = 1 # Head of tree
p_coeff_mu = 0 # Mu
p_param_gi_prob = 0.4 # Dictates binomial distribution sampling of g, covariate
p_param_sigma_beta = 5 # Dictates level of beta noise
p_num_sims = 1000 # Number of simulations
p_seed = 20
```


## Beta = 1.1
Specs:
```{r}
p_coeff_beta = 1.1 # Beta
```

### 0.8/0.2
```{r, include = FALSE}
p_grped_eps_11 = c(rep(0.8,(length(p_tying_grp)-1)),0)
p_grped_eps_10 = c(rep(0.2,(length(p_tying_grp)-1)),0)

if(run_sims){
  sim_08_02 <- run_sim2(
  n_ind = p_n_ind
  ,n_pheno = p_n_pheno
  ,tying_grp = p_tying_grp
  ,param_pi_00 = p_param_pi_00
  ,param_pi_11 = p_param_pi_11
  ,grped_eps_11 = p_grped_eps_11
  ,grped_eps_10 = p_grped_eps_10
  ,coeff_mu = p_coeff_mu
  ,coeff_beta = p_coeff_beta
  ,param_gi_prob = p_param_gi_prob
  ,param_sigma_beta = p_param_sigma_beta
  ,num_sims = p_num_sims
  ,seed = p_seed)
  if(save_sims & overwrite_data){
    saveRDS(sim_08_02, "~/Cpp/WaveQTL_HMT/data/Simul2_Data/sim2_beta_11_08_02.RDS", compress = T)
  }
}else{
  sim_08_02 <- readRDS("~/Cpp/WaveQTL_HMT/data/Simul2_Data/sim2_beta_11_08_02.RDS")
}

```
Summary of gamma proportions which we simulated, at each tying group.
```{r, include = F}
gamma_summaries <- lapply(sim_08_02$results_gamma_seq, function(x){
  resulting_gamma_proportion <- get_gamma_transition_props(eps_no_scale_data = x[-1]
                                                           ,tying_grp_vect = p_tying_grp
                                                           ,n_pheno = p_n_pheno)
  resulting_gamma_proportion[,c("sim_eps_11","sim_eps_10") :=
                               .(`11`/(`11`+`01`)
                                 ,`10`/(`10`+`00`))]
})
eps_11_summary <- matrix(unlist(lapply(gamma_summaries,function(x){x[,"sim_eps_11"]})),nrow = p_num_sims, ncol = nrow(gamma_summaries[[1]]),byrow = T)
empirical_eps_11_mean <- apply(eps_11_summary,2,mean)
eps_10_summary <- matrix(unlist(lapply(gamma_summaries,function(x){x[,"sim_eps_10"]})),nrow = p_num_sims, ncol = nrow(gamma_summaries[[1]]),byrow = T)
empirical_eps_10_mean <- apply(eps_10_summary,2,mean)
```

Analysis of results from 0.8/0.2 simulation, using 3 $\times$ standard deviation as the bounds here.
```{r, echo = F}
# Plots of the simulated data.

# Sample - one simulation's gamma sequence and y values
sim_number <- 20
g_sample <- tree_plot(sim_08_02$results_gamma_seq[[sim_number]],yaxis_lims = c(0,1), plot_title = paste0("Simulated gamma sequence - simulation ",sim_number))
y_avg_sample <- apply(sim_08_02$results_y_mtx[[sim_number]],MARGIN = 2,mean)
y_avg_sample_plot <- tree_plot(y_avg_sample
                               ,yaxis_lims = c(min(y_avg_sample)
                                               ,max(y_avg_sample)), plot_title = paste0("Simulated y value - simulation ",sim_number))
graphics.off()

# Calculations
pi_mean <- mean(unlist(sim_08_02$results_pi))
pi_sd <- sd(unlist(sim_08_02$results_pi))
pi_range <- c(pi_mean - 3*pi_sd, pi_mean + 3*pi_sd)

results_eps_11_mtx <- matrix(unlist(sim_08_02$results_eps_11)
                             ,nrow = p_num_sims, ncol = (p_n_pheno - 2), byrow = T)
results_eps_10_mtx <- matrix(unlist(sim_08_02$results_eps_10)
                             ,nrow = p_num_sims, ncol = (p_n_pheno - 2), byrow = T)

eps_11_mean <- apply(results_eps_11_mtx,MARGIN = 2,mean)
eps_11_sd <- apply(results_eps_11_mtx,MARGIN = 2,sd)
eps_11_lb <- eps_11_mean - 3*eps_11_sd
eps_11_ub <- eps_11_mean + 3*eps_11_sd

eps_10_mean <- apply(results_eps_10_mtx,MARGIN = 2,mean)
eps_10_sd <- apply(results_eps_10_mtx,MARGIN = 2,sd)
eps_10_lb <- eps_10_mean - 3*eps_10_sd
eps_10_ub <- eps_10_mean + 3*eps_10_sd

# Set up empirical epsilons for comparison
empirical_eps_11 <- c(rep(empirical_eps_11_mean[1],2)) # top two of tree
empirical_eps_10 <- c(rep(empirical_eps_10_mean[1],2)) # top two of tree
for(i in 3:(length(p_tying_grp)-1)){
  st <- p_tying_grp[i]
  end <- p_tying_grp[i+1]-1
  empirical_eps_11[st:end] <- empirical_eps_11[i-2]
  empirical_eps_10[st:end] <- empirical_eps_10[i-2]
}
empirical_eps_11[(end + 1):p_n_pheno] <- empirical_eps_11_mean[i-1]
empirical_eps_10[(end + 1):p_n_pheno] <- empirical_eps_10_mean[i-1]

# Plots
# Epsilon 11
y_axis_bounds <- c(min(min(eps_11_lb),min(sim_08_02$param_eps_11)),max(max(eps_11_ub),max(sim_08_02$param_eps_11)))*1.1

xval = 3:p_n_pheno
which_in_bound = xval[between(sim_08_02$param_eps_11,eps_11_lb,eps_11_ub)]

plot(1,1, type = "n", xlab = "Wavelet scale-loc", ylab = "Probability", main = "Epsilon 11", xaxt = "n"
     ,xlim = c(3,p_n_pheno)
     ,ylim = y_axis_bounds)
if(length(which_in_bound) > 0){
  for(j in 1:length(which_in_bound)){
    polygon(c(which_in_bound[j]-0.5, which_in_bound[j]-0.5, which_in_bound[j]+0.5, which_in_bound[j]+0.5), c(y_axis_bounds[1], y_axis_bounds[2],  y_axis_bounds[2],  y_axis_bounds[1])
            , col ="pink", border = NA)
  }
}

axis(1,at = 2^(3:10),labels = 2^(3:10),las = 2)
points(x = xval, y = sim_08_02$param_eps_11,type = "l")
points(x = xval, empirical_eps_11[-c(1:2)],col = "green", type = "l")
points(x = xval, eps_11_mean,col = "red", type = "l")
points(x = xval, eps_11_ub,col = "blue", type = "l", lty = 2)
points(x = xval, eps_11_lb,col = "blue", type = "l", lty = 2)
legend("topright"
       ,inset = 0.02
       ,legend = c("Input","Simulated (avg)","Estimated (avg)")
       ,title = "Epsilon"
       ,col = c("Black","Green","Red")
       ,lty = rep(1,3)
       ,cex = 0.6
       ,bty = "n"
       ,box.lty = 0)

# Epsilon 10
y_axis_bounds <- c(min(min(eps_10_lb),min(sim_08_02$param_eps_10)),max(max(eps_10_ub),max(sim_08_02$param_eps_10)))*1.1

xval = 3:p_n_pheno
which_in_bound = xval[between(sim_08_02$param_eps_10,eps_10_lb,eps_10_ub)]

plot(1,1, type = "n", xlab = "Wavelet scale-loc", ylab = "Probability", main = "Epsilon 10", xaxt = "n"
     ,xlim = c(3,p_n_pheno)
     ,ylim = y_axis_bounds)
if(length(which_in_bound) > 0){
  for(j in 1:length(which_in_bound)){
    polygon(c(which_in_bound[j]-0.5, which_in_bound[j]-0.5, which_in_bound[j]+0.5, which_in_bound[j]+0.5), c(y_axis_bounds[1], y_axis_bounds[2],  y_axis_bounds[2],  y_axis_bounds[1])
            , col ="pink", border = NA)
  }
}

axis(1,at = 2^(3:10),labels = 2^(3:10),las = 2)
points(x = xval, y = sim_08_02$param_eps_10,type = "l")
points(x = xval, empirical_eps_10[-c(1:2)],col = "green", type = "l")
points(x = xval, eps_10_mean,col = "red", type = "l")
points(x = xval, eps_10_ub,col = "blue", type = "l", lty = 2)
points(x = xval, eps_10_lb,col = "blue", type = "l", lty = 2)
legend("topright"
       ,inset = 0.02
       ,legend = c("Input","Simulated (avg)","Estimated (avg)")
       ,title = "Epsilon"
       ,col = c("Black","Green","Red")
       ,lty = rep(1,3)
       ,cex = 0.6
       ,bty = "n"
       ,box.lty = 0)
```

### 0.7/0.3
```{r, include = FALSE}
p_grped_eps_11 = c(rep(0.7,(length(p_tying_grp)-1)),0)
p_grped_eps_10 = c(rep(0.3,(length(p_tying_grp)-1)),0)

if(run_sims){
  sim_07_03 <- run_sim2(
  n_ind = p_n_ind
  ,n_pheno = p_n_pheno
  ,tying_grp = p_tying_grp
  ,param_pi_00 = p_param_pi_00
  ,param_pi_11 = p_param_pi_11
  ,grped_eps_11 = p_grped_eps_11
  ,grped_eps_10 = p_grped_eps_10
  ,coeff_mu = p_coeff_mu
  ,coeff_beta = p_coeff_beta
  ,param_gi_prob = p_param_gi_prob
  ,param_sigma_beta = p_param_sigma_beta
  ,num_sims = p_num_sims
  ,seed = p_seed)
  if(save_sims & overwrite_data){
    saveRDS(sim_07_03, "~/Cpp/WaveQTL_HMT/data/Simul2_Data/sim2_beta_11_07_03.RDS", compress = T)
  }
}else{
  sim_07_03 <- readRDS("~/Cpp/WaveQTL_HMT/data/Simul2_Data/sim2_beta_11_07_03.RDS")
}
```
Summary of gamma proportions which we simulated, at each tying group.
```{r, include = F}
gamma_summaries <- lapply(sim_07_03$results_gamma_seq, function(x){
  resulting_gamma_proportion <- get_gamma_transition_props(eps_no_scale_data = x[-1]
                                                           ,tying_grp_vect = p_tying_grp
                                                           ,n_pheno = p_n_pheno)
  resulting_gamma_proportion[,c("sim_eps_11","sim_eps_10") :=
                               .(`11`/(`11`+`01`)
                                 ,`10`/(`10`+`00`))]
})
eps_11_summary <- matrix(unlist(lapply(gamma_summaries,function(x){x[,"sim_eps_11"]})),nrow = p_num_sims, ncol = nrow(gamma_summaries[[1]]),byrow = T)
empirical_eps_11_mean <- apply(eps_11_summary,2,mean)
eps_10_summary <- matrix(unlist(lapply(gamma_summaries,function(x){x[,"sim_eps_10"]})),nrow = p_num_sims, ncol = nrow(gamma_summaries[[1]]),byrow = T)
empirical_eps_10_mean <- apply(eps_10_summary,2,mean)
```

Analysis of results from 0.7/0.3 simulation, using 3 $\times$ standard deviation as the bounds here.
```{r, echo = F}
# Plots of the simulated data.

# Sample - one simulation's gamma sequence and y values
sim_number <- 20
g_sample <- tree_plot(sim_07_03$results_gamma_seq[[sim_number]],yaxis_lims = c(0,1), plot_title = paste0("Simulated gamma sequence - simulation ",sim_number))
y_avg_sample <- apply(sim_07_03$results_y_mtx[[sim_number]],MARGIN = 2,mean)
y_avg_sample_plot <- tree_plot(y_avg_sample
                               ,yaxis_lims = c(min(y_avg_sample)
                                               ,max(y_avg_sample)), plot_title = paste0("Simulated y value - simulation ",sim_number))
graphics.off()

# Calculations
pi_mean <- mean(unlist(sim_07_03$results_pi))
pi_sd <- sd(unlist(sim_07_03$results_pi))
pi_range <- c(pi_mean - 3*pi_sd, pi_mean + 3*pi_sd)

results_eps_11_mtx <- matrix(unlist(sim_07_03$results_eps_11)
                             ,nrow = p_num_sims, ncol = (p_n_pheno - 2), byrow = T)
results_eps_10_mtx <- matrix(unlist(sim_07_03$results_eps_10)
                             ,nrow = p_num_sims, ncol = (p_n_pheno - 2), byrow = T)

eps_11_mean <- apply(results_eps_11_mtx,MARGIN = 2,mean)
eps_11_sd <- apply(results_eps_11_mtx,MARGIN = 2,sd)
eps_11_lb <- eps_11_mean - 3*eps_11_sd
eps_11_ub <- eps_11_mean + 3*eps_11_sd

eps_10_mean <- apply(results_eps_10_mtx,MARGIN = 2,mean)
eps_10_sd <- apply(results_eps_10_mtx,MARGIN = 2,sd)
eps_10_lb <- eps_10_mean - 3*eps_10_sd
eps_10_ub <- eps_10_mean + 3*eps_10_sd

# Set up empirical epsilons for comparison
empirical_eps_11 <- c(rep(empirical_eps_11_mean[1],2)) # top two of tree
empirical_eps_10 <- c(rep(empirical_eps_10_mean[1],2)) # top two of tree
for(i in 3:(length(p_tying_grp)-1)){
  st <- p_tying_grp[i]
  end <- p_tying_grp[i+1]-1
  empirical_eps_11[st:end] <- empirical_eps_11[i-2]
  empirical_eps_10[st:end] <- empirical_eps_10[i-2]
}
empirical_eps_11[(end + 1):p_n_pheno] <- empirical_eps_11_mean[i-1]
empirical_eps_10[(end + 1):p_n_pheno] <- empirical_eps_10_mean[i-1]

# Plots
# Epsilon 11
y_axis_bounds <- c(min(min(eps_11_lb),min(sim_07_03$param_eps_11)),max(max(eps_11_ub),max(sim_07_03$param_eps_11)))*1.1

xval = 3:p_n_pheno
which_in_bound = xval[between(sim_07_03$param_eps_11,eps_11_lb,eps_11_ub)]

plot(1,1, type = "n", xlab = "Wavelet scale-loc", ylab = "Probability", main = "Epsilon 11", xaxt = "n"
     ,xlim = c(3,p_n_pheno)
     ,ylim = y_axis_bounds)
if(length(which_in_bound) > 0){
  for(j in 1:length(which_in_bound)){
    polygon(c(which_in_bound[j]-0.5, which_in_bound[j]-0.5, which_in_bound[j]+0.5, which_in_bound[j]+0.5), c(y_axis_bounds[1], y_axis_bounds[2],  y_axis_bounds[2],  y_axis_bounds[1])
            , col ="pink", border = NA)
  }
}

axis(1,at = 2^(3:10),labels = 2^(3:10),las = 2)
points(x = xval, y = sim_07_03$param_eps_11,type = "l")
points(x = xval, empirical_eps_11[-c(1:2)],col = "green", type = "l")
points(x = xval, eps_11_mean,col = "red", type = "l")
points(x = xval, eps_11_ub,col = "blue", type = "l", lty = 2)
points(x = xval, eps_11_lb,col = "blue", type = "l", lty = 2)
legend("topright"
       ,inset = 0.02
       ,legend = c("Input","Simulated (avg)","Estimated (avg)")
       ,title = "Epsilon"
       ,col = c("Black","Green","Red")
       ,lty = rep(1,3)
       ,cex = 0.6
       ,bty = "n"
       ,box.lty = 0)

# Epsilon 10
y_axis_bounds <- c(min(min(eps_10_lb),min(sim_07_03$param_eps_10)),max(max(eps_10_ub),max(sim_07_03$param_eps_10)))*1.1

xval = 3:p_n_pheno
which_in_bound = xval[between(sim_07_03$param_eps_10,eps_10_lb,eps_10_ub)]

plot(1,1, type = "n", xlab = "Wavelet scale-loc", ylab = "Probability", main = "Epsilon 10", xaxt = "n"
     ,xlim = c(3,p_n_pheno)
     ,ylim = y_axis_bounds)
if(length(which_in_bound) > 0){
  for(j in 1:length(which_in_bound)){
    polygon(c(which_in_bound[j]-0.5, which_in_bound[j]-0.5, which_in_bound[j]+0.5, which_in_bound[j]+0.5), c(y_axis_bounds[1], y_axis_bounds[2],  y_axis_bounds[2],  y_axis_bounds[1])
            , col ="pink", border = NA)
  }
}

axis(1,at = 2^(3:10),labels = 2^(3:10),las = 2)
points(x = xval, y = sim_07_03$param_eps_10,type = "l")
points(x = xval, empirical_eps_10[-c(1:2)],col = "green", type = "l")
points(x = xval, eps_10_mean,col = "red", type = "l")
points(x = xval, eps_10_ub,col = "blue", type = "l", lty = 2)
points(x = xval, eps_10_lb,col = "blue", type = "l", lty = 2)
legend("topright"
       ,inset = 0.02
       ,legend = c("Input","Simulated (avg)","Estimated (avg)")
       ,title = "Epsilon"
       ,col = c("Black","Green","Red")
       ,lty = rep(1,3)
       ,cex = 0.6
       ,bty = "n"
       ,box.lty = 0)
```

### 0.7/0.7
```{r, include = FALSE}
p_grped_eps_11 = c(rep(0.7,(length(p_tying_grp)-1)),0)
p_grped_eps_10 = c(rep(0.7,(length(p_tying_grp)-1)),0)

if(run_sims){
  sim_07_07 <- run_sim2(
  n_ind = p_n_ind
  ,n_pheno = p_n_pheno
  ,tying_grp = p_tying_grp
  ,param_pi_00 = p_param_pi_00
  ,param_pi_11 = p_param_pi_11
  ,grped_eps_11 = p_grped_eps_11
  ,grped_eps_10 = p_grped_eps_10
  ,coeff_mu = p_coeff_mu
  ,coeff_beta = p_coeff_beta
  ,param_gi_prob = p_param_gi_prob
  ,param_sigma_beta = p_param_sigma_beta
  ,num_sims = p_num_sims
  ,seed = p_seed)
  if(save_sims & overwrite_data){
    saveRDS(sim_07_07, "~/Cpp/WaveQTL_HMT/data/Simul2_Data/sim2_beta_11_07_07.RDS", compress = T)
  }
}else{
  sim_07_07 <- readRDS("~/Cpp/WaveQTL_HMT/data/Simul2_Data/sim2_beta_11_07_07.RDS")
}
```
Summary of gamma proportions which we simulated, at each tying group.
```{r, include = F}
gamma_summaries <- lapply(sim_07_07$results_gamma_seq, function(x){
  resulting_gamma_proportion <- get_gamma_transition_props(eps_no_scale_data = x[-1]
                                                           ,tying_grp_vect = p_tying_grp
                                                           ,n_pheno = p_n_pheno)
  resulting_gamma_proportion[,c("sim_eps_11","sim_eps_10") :=
                               .(`11`/(`11`+`01`)
                                 ,`10`/(`10`+`00`))]
})
eps_11_summary <- matrix(unlist(lapply(gamma_summaries,function(x){x[,"sim_eps_11"]})),nrow = p_num_sims, ncol = nrow(gamma_summaries[[1]]),byrow = T)
empirical_eps_11_mean <- apply(eps_11_summary,2,mean)
eps_10_summary <- matrix(unlist(lapply(gamma_summaries,function(x){x[,"sim_eps_10"]})),nrow = p_num_sims, ncol = nrow(gamma_summaries[[1]]),byrow = T)
empirical_eps_10_mean <- apply(eps_10_summary,2,mean)
```

Analysis of results from 0.7/0.7 simulation, using 3 $\times$ standard deviation as the bounds here.
```{r, echo = F}
# Plots of the simulated data.

# Sample - one simulation's gamma sequence and y values
sim_number <- 20
g_sample <- tree_plot(sim_07_07$results_gamma_seq[[sim_number]],yaxis_lims = c(0,1), plot_title = paste0("Simulated gamma sequence - simulation ",sim_number))
y_avg_sample <- apply(sim_07_07$results_y_mtx[[sim_number]],MARGIN = 2,mean)
y_avg_sample_plot <- tree_plot(y_avg_sample
                               ,yaxis_lims = c(min(y_avg_sample)
                                               ,max(y_avg_sample)), plot_title = paste0("Simulated y value - simulation ",sim_number))
graphics.off()

# Calculations
pi_mean <- mean(unlist(sim_07_07$results_pi))
pi_sd <- sd(unlist(sim_07_07$results_pi))
pi_range <- c(pi_mean - 3*pi_sd, pi_mean + 3*pi_sd)

results_eps_11_mtx <- matrix(unlist(sim_07_07$results_eps_11)
                             ,nrow = p_num_sims, ncol = (p_n_pheno - 2), byrow = T)
results_eps_10_mtx <- matrix(unlist(sim_07_07$results_eps_10)
                             ,nrow = p_num_sims, ncol = (p_n_pheno - 2), byrow = T)

eps_11_mean <- apply(results_eps_11_mtx,MARGIN = 2,mean)
eps_11_sd <- apply(results_eps_11_mtx,MARGIN = 2,sd)
eps_11_lb <- eps_11_mean - 3*eps_11_sd
eps_11_ub <- eps_11_mean + 3*eps_11_sd

eps_10_mean <- apply(results_eps_10_mtx,MARGIN = 2,mean)
eps_10_sd <- apply(results_eps_10_mtx,MARGIN = 2,sd)
eps_10_lb <- eps_10_mean - 3*eps_10_sd
eps_10_ub <- eps_10_mean + 3*eps_10_sd

# Set up empirical epsilons for comparison
empirical_eps_11 <- c(rep(empirical_eps_11_mean[1],2)) # top two of tree
empirical_eps_10 <- c(rep(empirical_eps_10_mean[1],2)) # top two of tree
for(i in 3:(length(p_tying_grp)-1)){
  st <- p_tying_grp[i]
  end <- p_tying_grp[i+1]-1
  empirical_eps_11[st:end] <- empirical_eps_11[i-2]
  empirical_eps_10[st:end] <- empirical_eps_10[i-2]
}
empirical_eps_11[(end + 1):p_n_pheno] <- empirical_eps_11_mean[i-1]
empirical_eps_10[(end + 1):p_n_pheno] <- empirical_eps_10_mean[i-1]

# Plots
# Epsilon 11
y_axis_bounds <- c(min(min(eps_11_lb),min(sim_07_07$param_eps_11)),max(max(eps_11_ub),max(sim_07_07$param_eps_11)))*1.1

xval = 3:p_n_pheno
which_in_bound = xval[between(sim_07_07$param_eps_11,eps_11_lb,eps_11_ub)]

plot(1,1, type = "n", xlab = "Wavelet scale-loc", ylab = "Probability", main = "Epsilon 11", xaxt = "n"
     ,xlim = c(3,p_n_pheno)
     ,ylim = y_axis_bounds)
if(length(which_in_bound) > 0){
  for(j in 1:length(which_in_bound)){
    polygon(c(which_in_bound[j]-0.5, which_in_bound[j]-0.5, which_in_bound[j]+0.5, which_in_bound[j]+0.5), c(y_axis_bounds[1], y_axis_bounds[2],  y_axis_bounds[2],  y_axis_bounds[1])
            , col ="pink", border = NA)
  }
}

axis(1,at = 2^(3:10),labels = 2^(3:10),las = 2)
points(x = xval, y = sim_07_07$param_eps_11,type = "l")
points(x = xval, empirical_eps_11[-c(1:2)],col = "green", type = "l")
points(x = xval, eps_11_mean,col = "red", type = "l")
points(x = xval, eps_11_ub,col = "blue", type = "l", lty = 2)
points(x = xval, eps_11_lb,col = "blue", type = "l", lty = 2)
legend("topright"
       ,inset = 0.02
       ,legend = c("Input","Simulated (avg)","Estimated (avg)")
       ,title = "Epsilon"
       ,col = c("Black","Green","Red")
       ,lty = rep(1,3)
       ,cex = 0.6
       ,bty = "n"
       ,box.lty = 0)

# Epsilon 10
y_axis_bounds <- c(min(min(eps_10_lb),min(sim_07_07$param_eps_10)),max(max(eps_10_ub),max(sim_07_07$param_eps_10)))*1.1

xval = 3:p_n_pheno
which_in_bound = xval[between(sim_07_07$param_eps_10,eps_10_lb,eps_10_ub)]

plot(1,1, type = "n", xlab = "Wavelet scale-loc", ylab = "Probability", main = "Epsilon 10", xaxt = "n"
     ,xlim = c(3,p_n_pheno)
     ,ylim = y_axis_bounds)
if(length(which_in_bound) > 0){
  for(j in 1:length(which_in_bound)){
    polygon(c(which_in_bound[j]-0.5, which_in_bound[j]-0.5, which_in_bound[j]+0.5, which_in_bound[j]+0.5), c(y_axis_bounds[1], y_axis_bounds[2],  y_axis_bounds[2],  y_axis_bounds[1])
            , col ="pink", border = NA)
  }
}

axis(1,at = 2^(3:10),labels = 2^(3:10),las = 2)
points(x = xval, y = sim_07_07$param_eps_10,type = "l")
points(x = xval, empirical_eps_10[-c(1:2)],col = "green", type = "l")
points(x = xval, eps_10_mean,col = "red", type = "l")
points(x = xval, eps_10_ub,col = "blue", type = "l", lty = 2)
points(x = xval, eps_10_lb,col = "blue", type = "l", lty = 2)
legend("topright"
       ,inset = 0.02
       ,legend = c("Input","Simulated (avg)","Estimated (avg)")
       ,title = "Epsilon"
       ,col = c("Black","Green","Red")
       ,lty = rep(1,3)
       ,cex = 0.6
       ,bty = "n"
       ,box.lty = 0)
```

### 0.5/0.5
```{r, include = FALSE}
p_grped_eps_11 = c(rep(0.5,(length(p_tying_grp)-1)),0)
p_grped_eps_10 = c(rep(0.5,(length(p_tying_grp)-1)),0)

if(run_sims){
  sim_05_05 <- run_sim2(
  n_ind = p_n_ind
  ,n_pheno = p_n_pheno
  ,tying_grp = p_tying_grp
  ,param_pi_00 = p_param_pi_00
  ,param_pi_11 = p_param_pi_11
  ,grped_eps_11 = p_grped_eps_11
  ,grped_eps_10 = p_grped_eps_10
  ,coeff_mu = p_coeff_mu
  ,coeff_beta = p_coeff_beta
  ,param_gi_prob = p_param_gi_prob
  ,param_sigma_beta = p_param_sigma_beta
  ,num_sims = p_num_sims
  ,seed = p_seed)
  if(save_sims & overwrite_data){
    saveRDS(sim_05_05, "~/Cpp/WaveQTL_HMT/data/Simul2_Data/sim2_beta_11_05_05.RDS", compress = T)
  }
}else{
  sim_05_05 <- readRDS("~/Cpp/WaveQTL_HMT/data/Simul2_Data/sim2_beta_11_05_05.RDS")
}
```
Summary of gamma proportions which we simulated, at each tying group.
```{r, include = F}
gamma_summaries <- lapply(sim_05_05$results_gamma_seq, function(x){
  resulting_gamma_proportion <- get_gamma_transition_props(eps_no_scale_data = x[-1]
                                                           ,tying_grp_vect = p_tying_grp
                                                           ,n_pheno = p_n_pheno)
  resulting_gamma_proportion[,c("sim_eps_11","sim_eps_10") :=
                               .(`11`/(`11`+`01`)
                                 ,`10`/(`10`+`00`))]
})
eps_11_summary <- matrix(unlist(lapply(gamma_summaries,function(x){x[,"sim_eps_11"]})),nrow = p_num_sims, ncol = nrow(gamma_summaries[[1]]),byrow = T)
empirical_eps_11_mean <- apply(eps_11_summary,2,mean)
eps_10_summary <- matrix(unlist(lapply(gamma_summaries,function(x){x[,"sim_eps_10"]})),nrow = p_num_sims, ncol = nrow(gamma_summaries[[1]]),byrow = T)
empirical_eps_10_mean <- apply(eps_10_summary,2,mean)
```

Analysis of results from 0.5/0.5 simulation, using 3 $\times$ standard deviation as the bounds here.
```{r, echo = F}
# Plots of the simulated data.

# Sample - one simulation's gamma sequence and y values
sim_number <- 20
g_sample <- tree_plot(sim_05_05$results_gamma_seq[[sim_number]],yaxis_lims = c(0,1), plot_title = paste0("Simulated gamma sequence - simulation ",sim_number))
y_avg_sample <- apply(sim_05_05$results_y_mtx[[sim_number]],MARGIN = 2,mean)
y_avg_sample_plot <- tree_plot(y_avg_sample
                               ,yaxis_lims = c(min(y_avg_sample)
                                               ,max(y_avg_sample)), plot_title = paste0("Simulated y value - simulation ",sim_number))
graphics.off()

# Calculations
pi_mean <- mean(unlist(sim_05_05$results_pi))
pi_sd <- sd(unlist(sim_05_05$results_pi))
pi_range <- c(pi_mean - 3*pi_sd, pi_mean + 3*pi_sd)

results_eps_11_mtx <- matrix(unlist(sim_05_05$results_eps_11)
                             ,nrow = p_num_sims, ncol = (p_n_pheno - 2), byrow = T)
results_eps_10_mtx <- matrix(unlist(sim_05_05$results_eps_10)
                             ,nrow = p_num_sims, ncol = (p_n_pheno - 2), byrow = T)

eps_11_mean <- apply(results_eps_11_mtx,MARGIN = 2,mean)
eps_11_sd <- apply(results_eps_11_mtx,MARGIN = 2,sd)
eps_11_lb <- eps_11_mean - 3*eps_11_sd
eps_11_ub <- eps_11_mean + 3*eps_11_sd

eps_10_mean <- apply(results_eps_10_mtx,MARGIN = 2,mean)
eps_10_sd <- apply(results_eps_10_mtx,MARGIN = 2,sd)
eps_10_lb <- eps_10_mean - 3*eps_10_sd
eps_10_ub <- eps_10_mean + 3*eps_10_sd

# Set up empirical epsilons for comparison
empirical_eps_11 <- c(rep(empirical_eps_11_mean[1],2)) # top two of tree
empirical_eps_10 <- c(rep(empirical_eps_10_mean[1],2)) # top two of tree
for(i in 3:(length(p_tying_grp)-1)){
  st <- p_tying_grp[i]
  end <- p_tying_grp[i+1]-1
  empirical_eps_11[st:end] <- empirical_eps_11[i-2]
  empirical_eps_10[st:end] <- empirical_eps_10[i-2]
}
empirical_eps_11[(end + 1):p_n_pheno] <- empirical_eps_11_mean[i-1]
empirical_eps_10[(end + 1):p_n_pheno] <- empirical_eps_10_mean[i-1]

# Plots
# Epsilon 11
y_axis_bounds <- c(min(min(eps_11_lb),min(sim_05_05$param_eps_11)),max(max(eps_11_ub),max(sim_05_05$param_eps_11)))*1.1

xval = 3:p_n_pheno
which_in_bound = xval[between(sim_05_05$param_eps_11,eps_11_lb,eps_11_ub)]

plot(1,1, type = "n", xlab = "Wavelet scale-loc", ylab = "Probability", main = "Epsilon 11", xaxt = "n"
     ,xlim = c(3,p_n_pheno)
     ,ylim = y_axis_bounds)
if(length(which_in_bound) > 0){
  for(j in 1:length(which_in_bound)){
    polygon(c(which_in_bound[j]-0.5, which_in_bound[j]-0.5, which_in_bound[j]+0.5, which_in_bound[j]+0.5), c(y_axis_bounds[1], y_axis_bounds[2],  y_axis_bounds[2],  y_axis_bounds[1])
            , col ="pink", border = NA)
  }
}

axis(1,at = 2^(3:10),labels = 2^(3:10),las = 2)
points(x = xval, y = sim_05_05$param_eps_11,type = "l")
points(x = xval, empirical_eps_11[-c(1:2)],col = "green", type = "l")
points(x = xval, eps_11_mean,col = "red", type = "l")
points(x = xval, eps_11_ub,col = "blue", type = "l", lty = 2)
points(x = xval, eps_11_lb,col = "blue", type = "l", lty = 2)
legend("topright"
       ,inset = 0.02
       ,legend = c("Input","Simulated (avg)","Estimated (avg)")
       ,title = "Epsilon"
       ,col = c("Black","Green","Red")
       ,lty = rep(1,3)
       ,cex = 0.6
       ,bty = "n"
       ,box.lty = 0)

# Epsilon 10
y_axis_bounds <- c(min(min(eps_10_lb),min(sim_05_05$param_eps_10)),max(max(eps_10_ub),max(sim_05_05$param_eps_10)))*1.1

xval = 3:p_n_pheno
which_in_bound = xval[between(sim_05_05$param_eps_10,eps_10_lb,eps_10_ub)]

plot(1,1, type = "n", xlab = "Wavelet scale-loc", ylab = "Probability", main = "Epsilon 10", xaxt = "n"
     ,xlim = c(3,p_n_pheno)
     ,ylim = y_axis_bounds)
if(length(which_in_bound) > 0){
  for(j in 1:length(which_in_bound)){
    polygon(c(which_in_bound[j]-0.5, which_in_bound[j]-0.5, which_in_bound[j]+0.5, which_in_bound[j]+0.5), c(y_axis_bounds[1], y_axis_bounds[2],  y_axis_bounds[2],  y_axis_bounds[1])
            , col ="pink", border = NA)
  }
}

axis(1,at = 2^(3:10),labels = 2^(3:10),las = 2)
points(x = xval, y = sim_05_05$param_eps_10,type = "l")
points(x = xval, empirical_eps_10[-c(1:2)],col = "green", type = "l")
points(x = xval, eps_10_mean,col = "red", type = "l")
points(x = xval, eps_10_ub,col = "blue", type = "l", lty = 2)
points(x = xval, eps_10_lb,col = "blue", type = "l", lty = 2)
legend("topright"
       ,inset = 0.02
       ,legend = c("Input","Simulated (avg)","Estimated (avg)")
       ,title = "Epsilon"
       ,col = c("Black","Green","Red")
       ,lty = rep(1,3)
       ,cex = 0.6
       ,bty = "n"
       ,box.lty = 0)
```

## Beta = 1.3
```{r}
p_coeff_beta = 1.3 # Beta
```

### 0.8/0.2
```{r, include = FALSE}
p_grped_eps_11 = c(rep(0.8,(length(p_tying_grp)-1)),0)
p_grped_eps_10 = c(rep(0.2,(length(p_tying_grp)-1)),0)

if(run_sims){
  sim_08_02 <- run_sim2(
  n_ind = p_n_ind
  ,n_pheno = p_n_pheno
  ,tying_grp = p_tying_grp
  ,param_pi_00 = p_param_pi_00
  ,param_pi_11 = p_param_pi_11
  ,grped_eps_11 = p_grped_eps_11
  ,grped_eps_10 = p_grped_eps_10
  ,coeff_mu = p_coeff_mu
  ,coeff_beta = p_coeff_beta
  ,param_gi_prob = p_param_gi_prob
  ,param_sigma_beta = p_param_sigma_beta
  ,num_sims = p_num_sims
  ,seed = p_seed)
  if(save_sims & overwrite_data){
    saveRDS(sim_08_02, "~/Cpp/WaveQTL_HMT/data/Simul2_Data/sim2_beta_13_08_02.RDS", compress = T)
  }
}else{
  sim_08_02 <- readRDS("~/Cpp/WaveQTL_HMT/data/Simul2_Data/sim2_beta_13_08_02.RDS")
}

```
Summary of gamma proportions which we simulated, at each tying group.
```{r, include = F}
gamma_summaries <- lapply(sim_08_02$results_gamma_seq, function(x){
  resulting_gamma_proportion <- get_gamma_transition_props(eps_no_scale_data = x[-1]
                                                           ,tying_grp_vect = p_tying_grp
                                                           ,n_pheno = p_n_pheno)
  resulting_gamma_proportion[,c("sim_eps_11","sim_eps_10") :=
                               .(`11`/(`11`+`01`)
                                 ,`10`/(`10`+`00`))]
})
eps_11_summary <- matrix(unlist(lapply(gamma_summaries,function(x){x[,"sim_eps_11"]})),nrow = p_num_sims, ncol = nrow(gamma_summaries[[1]]),byrow = T)
empirical_eps_11_mean <- apply(eps_11_summary,2,mean)
eps_10_summary <- matrix(unlist(lapply(gamma_summaries,function(x){x[,"sim_eps_10"]})),nrow = p_num_sims, ncol = nrow(gamma_summaries[[1]]),byrow = T)
empirical_eps_10_mean <- apply(eps_10_summary,2,mean)
```

Analysis of results from 0.8/0.2 simulation, using 3 $\times$ standard deviation as the bounds here.
```{r, echo = F}
# Plots of the simulated data.

# Sample - one simulation's gamma sequence and y values
sim_number <- 20
g_sample <- tree_plot(sim_08_02$results_gamma_seq[[sim_number]],yaxis_lims = c(0,1), plot_title = paste0("Simulated gamma sequence - simulation ",sim_number))
y_avg_sample <- apply(sim_08_02$results_y_mtx[[sim_number]],MARGIN = 2,mean)
y_avg_sample_plot <- tree_plot(y_avg_sample
                               ,yaxis_lims = c(min(y_avg_sample)
                                               ,max(y_avg_sample)), plot_title = paste0("Simulated y value - simulation ",sim_number))
graphics.off()

# Calculations
pi_mean <- mean(unlist(sim_08_02$results_pi))
pi_sd <- sd(unlist(sim_08_02$results_pi))
pi_range <- c(pi_mean - 3*pi_sd, pi_mean + 3*pi_sd)

results_eps_11_mtx <- matrix(unlist(sim_08_02$results_eps_11)
                             ,nrow = p_num_sims, ncol = (p_n_pheno - 2), byrow = T)
results_eps_10_mtx <- matrix(unlist(sim_08_02$results_eps_10)
                             ,nrow = p_num_sims, ncol = (p_n_pheno - 2), byrow = T)

eps_11_mean <- apply(results_eps_11_mtx,MARGIN = 2,mean)
eps_11_sd <- apply(results_eps_11_mtx,MARGIN = 2,sd)
eps_11_lb <- eps_11_mean - 3*eps_11_sd
eps_11_ub <- eps_11_mean + 3*eps_11_sd

eps_10_mean <- apply(results_eps_10_mtx,MARGIN = 2,mean)
eps_10_sd <- apply(results_eps_10_mtx,MARGIN = 2,sd)
eps_10_lb <- eps_10_mean - 3*eps_10_sd
eps_10_ub <- eps_10_mean + 3*eps_10_sd

# Set up empirical epsilons for comparison
empirical_eps_11 <- c(rep(empirical_eps_11_mean[1],2)) # top two of tree
empirical_eps_10 <- c(rep(empirical_eps_10_mean[1],2)) # top two of tree
for(i in 3:(length(p_tying_grp)-1)){
  st <- p_tying_grp[i]
  end <- p_tying_grp[i+1]-1
  empirical_eps_11[st:end] <- empirical_eps_11[i-2]
  empirical_eps_10[st:end] <- empirical_eps_10[i-2]
}
empirical_eps_11[(end + 1):p_n_pheno] <- empirical_eps_11_mean[i-1]
empirical_eps_10[(end + 1):p_n_pheno] <- empirical_eps_10_mean[i-1]

# Plots
# Epsilon 11
y_axis_bounds <- c(min(min(eps_11_lb),min(sim_08_02$param_eps_11)),max(max(eps_11_ub),max(sim_08_02$param_eps_11)))*1.1

xval = 3:p_n_pheno
which_in_bound = xval[between(sim_08_02$param_eps_11,eps_11_lb,eps_11_ub)]

plot(1,1, type = "n", xlab = "Wavelet scale-loc", ylab = "Probability", main = "Epsilon 11", xaxt = "n"
     ,xlim = c(3,p_n_pheno)
     ,ylim = y_axis_bounds)
if(length(which_in_bound) > 0){
  for(j in 1:length(which_in_bound)){
    polygon(c(which_in_bound[j]-0.5, which_in_bound[j]-0.5, which_in_bound[j]+0.5, which_in_bound[j]+0.5), c(y_axis_bounds[1], y_axis_bounds[2],  y_axis_bounds[2],  y_axis_bounds[1])
            , col ="pink", border = NA)
  }
}

axis(1,at = 2^(3:10),labels = 2^(3:10),las = 2)
points(x = xval, y = sim_08_02$param_eps_11,type = "l")
points(x = xval, empirical_eps_11[-c(1:2)],col = "green", type = "l")
points(x = xval, eps_11_mean,col = "red", type = "l")
points(x = xval, eps_11_ub,col = "blue", type = "l", lty = 2)
points(x = xval, eps_11_lb,col = "blue", type = "l", lty = 2)
legend("topright"
       ,inset = 0.02
       ,legend = c("Input","Simulated (avg)","Estimated (avg)")
       ,title = "Epsilon"
       ,col = c("Black","Green","Red")
       ,lty = rep(1,3)
       ,cex = 0.6
       ,bty = "n"
       ,box.lty = 0)

# Epsilon 10
y_axis_bounds <- c(min(min(eps_10_lb),min(sim_08_02$param_eps_10)),max(max(eps_10_ub),max(sim_08_02$param_eps_10)))*1.1

xval = 3:p_n_pheno
which_in_bound = xval[between(sim_08_02$param_eps_10,eps_10_lb,eps_10_ub)]

plot(1,1, type = "n", xlab = "Wavelet scale-loc", ylab = "Probability", main = "Epsilon 10", xaxt = "n"
     ,xlim = c(3,p_n_pheno)
     ,ylim = y_axis_bounds)
if(length(which_in_bound) > 0){
  for(j in 1:length(which_in_bound)){
    polygon(c(which_in_bound[j]-0.5, which_in_bound[j]-0.5, which_in_bound[j]+0.5, which_in_bound[j]+0.5), c(y_axis_bounds[1], y_axis_bounds[2],  y_axis_bounds[2],  y_axis_bounds[1])
            , col ="pink", border = NA)
  }
}

axis(1,at = 2^(3:10),labels = 2^(3:10),las = 2)
points(x = xval, y = sim_08_02$param_eps_10,type = "l")
points(x = xval, empirical_eps_10[-c(1:2)],col = "green", type = "l")
points(x = xval, eps_10_mean,col = "red", type = "l")
points(x = xval, eps_10_ub,col = "blue", type = "l", lty = 2)
points(x = xval, eps_10_lb,col = "blue", type = "l", lty = 2)
legend("topright"
       ,inset = 0.02
       ,legend = c("Input","Simulated (avg)","Estimated (avg)")
       ,title = "Epsilon"
       ,col = c("Black","Green","Red")
       ,lty = rep(1,3)
       ,cex = 0.6
       ,bty = "n"
       ,box.lty = 0)
```

### 0.7/0.3
```{r, include = FALSE}
p_grped_eps_11 = c(rep(0.7,(length(p_tying_grp)-1)),0)
p_grped_eps_10 = c(rep(0.3,(length(p_tying_grp)-1)),0)

if(run_sims){
  sim_07_03 <- run_sim2(
  n_ind = p_n_ind
  ,n_pheno = p_n_pheno
  ,tying_grp = p_tying_grp
  ,param_pi_00 = p_param_pi_00
  ,param_pi_11 = p_param_pi_11
  ,grped_eps_11 = p_grped_eps_11
  ,grped_eps_10 = p_grped_eps_10
  ,coeff_mu = p_coeff_mu
  ,coeff_beta = p_coeff_beta
  ,param_gi_prob = p_param_gi_prob
  ,param_sigma_beta = p_param_sigma_beta
  ,num_sims = p_num_sims
  ,seed = p_seed)
  if(save_sims & overwrite_data){
    saveRDS(sim_07_03, "~/Cpp/WaveQTL_HMT/data/Simul2_Data/sim2_beta_13_07_03.RDS", compress = T)
  }
}else{
  sim_07_03 <- readRDS("~/Cpp/WaveQTL_HMT/data/Simul2_Data/sim2_beta_13_07_03.RDS")
}
```
Summary of gamma proportions which we simulated, at each tying group.
```{r, include = F}
gamma_summaries <- lapply(sim_07_03$results_gamma_seq, function(x){
  resulting_gamma_proportion <- get_gamma_transition_props(eps_no_scale_data = x[-1]
                                                           ,tying_grp_vect = p_tying_grp
                                                           ,n_pheno = p_n_pheno)
  resulting_gamma_proportion[,c("sim_eps_11","sim_eps_10") :=
                               .(`11`/(`11`+`01`)
                                 ,`10`/(`10`+`00`))]
})
eps_11_summary <- matrix(unlist(lapply(gamma_summaries,function(x){x[,"sim_eps_11"]})),nrow = p_num_sims, ncol = nrow(gamma_summaries[[1]]),byrow = T)
empirical_eps_11_mean <- apply(eps_11_summary,2,mean)
eps_10_summary <- matrix(unlist(lapply(gamma_summaries,function(x){x[,"sim_eps_10"]})),nrow = p_num_sims, ncol = nrow(gamma_summaries[[1]]),byrow = T)
empirical_eps_10_mean <- apply(eps_10_summary,2,mean)
```

Analysis of results from 0.7/0.3 simulation, using 3 $\times$ standard deviation as the bounds here.
```{r, echo = F}
# Plots of the simulated data.

# Sample - one simulation's gamma sequence and y values
sim_number <- 20
g_sample <- tree_plot(sim_07_03$results_gamma_seq[[sim_number]],yaxis_lims = c(0,1), plot_title = paste0("Simulated gamma sequence - simulation ",sim_number))
y_avg_sample <- apply(sim_07_03$results_y_mtx[[sim_number]],MARGIN = 2,mean)
y_avg_sample_plot <- tree_plot(y_avg_sample
                               ,yaxis_lims = c(min(y_avg_sample)
                                               ,max(y_avg_sample)), plot_title = paste0("Simulated y value - simulation ",sim_number))
graphics.off()

# Calculations
pi_mean <- mean(unlist(sim_07_03$results_pi))
pi_sd <- sd(unlist(sim_07_03$results_pi))
pi_range <- c(pi_mean - 3*pi_sd, pi_mean + 3*pi_sd)

results_eps_11_mtx <- matrix(unlist(sim_07_03$results_eps_11)
                             ,nrow = p_num_sims, ncol = (p_n_pheno - 2), byrow = T)
results_eps_10_mtx <- matrix(unlist(sim_07_03$results_eps_10)
                             ,nrow = p_num_sims, ncol = (p_n_pheno - 2), byrow = T)

eps_11_mean <- apply(results_eps_11_mtx,MARGIN = 2,mean)
eps_11_sd <- apply(results_eps_11_mtx,MARGIN = 2,sd)
eps_11_lb <- eps_11_mean - 3*eps_11_sd
eps_11_ub <- eps_11_mean + 3*eps_11_sd

eps_10_mean <- apply(results_eps_10_mtx,MARGIN = 2,mean)
eps_10_sd <- apply(results_eps_10_mtx,MARGIN = 2,sd)
eps_10_lb <- eps_10_mean - 3*eps_10_sd
eps_10_ub <- eps_10_mean + 3*eps_10_sd

# Set up empirical epsilons for comparison
empirical_eps_11 <- c(rep(empirical_eps_11_mean[1],2)) # top two of tree
empirical_eps_10 <- c(rep(empirical_eps_10_mean[1],2)) # top two of tree
for(i in 3:(length(p_tying_grp)-1)){
  st <- p_tying_grp[i]
  end <- p_tying_grp[i+1]-1
  empirical_eps_11[st:end] <- empirical_eps_11[i-2]
  empirical_eps_10[st:end] <- empirical_eps_10[i-2]
}
empirical_eps_11[(end + 1):p_n_pheno] <- empirical_eps_11_mean[i-1]
empirical_eps_10[(end + 1):p_n_pheno] <- empirical_eps_10_mean[i-1]

# Plots
# Epsilon 11
y_axis_bounds <- c(min(min(eps_11_lb),min(sim_07_03$param_eps_11)),max(max(eps_11_ub),max(sim_07_03$param_eps_11)))*1.1

xval = 3:p_n_pheno
which_in_bound = xval[between(sim_07_03$param_eps_11,eps_11_lb,eps_11_ub)]

plot(1,1, type = "n", xlab = "Wavelet scale-loc", ylab = "Probability", main = "Epsilon 11", xaxt = "n"
     ,xlim = c(3,p_n_pheno)
     ,ylim = y_axis_bounds)
if(length(which_in_bound) > 0){
  for(j in 1:length(which_in_bound)){
    polygon(c(which_in_bound[j]-0.5, which_in_bound[j]-0.5, which_in_bound[j]+0.5, which_in_bound[j]+0.5), c(y_axis_bounds[1], y_axis_bounds[2],  y_axis_bounds[2],  y_axis_bounds[1])
            , col ="pink", border = NA)
  }
}

axis(1,at = 2^(3:10),labels = 2^(3:10),las = 2)
points(x = xval, y = sim_07_03$param_eps_11,type = "l")
points(x = xval, empirical_eps_11[-c(1:2)],col = "green", type = "l")
points(x = xval, eps_11_mean,col = "red", type = "l")
points(x = xval, eps_11_ub,col = "blue", type = "l", lty = 2)
points(x = xval, eps_11_lb,col = "blue", type = "l", lty = 2)
legend("topright"
       ,inset = 0.02
       ,legend = c("Input","Simulated (avg)","Estimated (avg)")
       ,title = "Epsilon"
       ,col = c("Black","Green","Red")
       ,lty = rep(1,3)
       ,cex = 0.6
       ,bty = "n"
       ,box.lty = 0)

# Epsilon 10
y_axis_bounds <- c(min(min(eps_10_lb),min(sim_07_03$param_eps_10)),max(max(eps_10_ub),max(sim_07_03$param_eps_10)))*1.1

xval = 3:p_n_pheno
which_in_bound = xval[between(sim_07_03$param_eps_10,eps_10_lb,eps_10_ub)]

plot(1,1, type = "n", xlab = "Wavelet scale-loc", ylab = "Probability", main = "Epsilon 10", xaxt = "n"
     ,xlim = c(3,p_n_pheno)
     ,ylim = y_axis_bounds)
if(length(which_in_bound) > 0){
  for(j in 1:length(which_in_bound)){
    polygon(c(which_in_bound[j]-0.5, which_in_bound[j]-0.5, which_in_bound[j]+0.5, which_in_bound[j]+0.5), c(y_axis_bounds[1], y_axis_bounds[2],  y_axis_bounds[2],  y_axis_bounds[1])
            , col ="pink", border = NA)
  }
}

axis(1,at = 2^(3:10),labels = 2^(3:10),las = 2)
points(x = xval, y = sim_07_03$param_eps_10,type = "l")
points(x = xval, empirical_eps_10[-c(1:2)],col = "green", type = "l")
points(x = xval, eps_10_mean,col = "red", type = "l")
points(x = xval, eps_10_ub,col = "blue", type = "l", lty = 2)
points(x = xval, eps_10_lb,col = "blue", type = "l", lty = 2)
legend("topright"
       ,inset = 0.02
       ,legend = c("Input","Simulated (avg)","Estimated (avg)")
       ,title = "Epsilon"
       ,col = c("Black","Green","Red")
       ,lty = rep(1,3)
       ,cex = 0.6
       ,bty = "n"
       ,box.lty = 0)
```

### 0.7/0.7
```{r, include = FALSE}
p_grped_eps_11 = c(rep(0.7,(length(p_tying_grp)-1)),0)
p_grped_eps_10 = c(rep(0.7,(length(p_tying_grp)-1)),0)

if(run_sims){
  sim_07_07 <- run_sim2(
  n_ind = p_n_ind
  ,n_pheno = p_n_pheno
  ,tying_grp = p_tying_grp
  ,param_pi_00 = p_param_pi_00
  ,param_pi_11 = p_param_pi_11
  ,grped_eps_11 = p_grped_eps_11
  ,grped_eps_10 = p_grped_eps_10
  ,coeff_mu = p_coeff_mu
  ,coeff_beta = p_coeff_beta
  ,param_gi_prob = p_param_gi_prob
  ,param_sigma_beta = p_param_sigma_beta
  ,num_sims = p_num_sims
  ,seed = p_seed)
  if(save_sims & overwrite_data){
    saveRDS(sim_07_07, "~/Cpp/WaveQTL_HMT/data/Simul2_Data/sim2_beta_13_07_07.RDS", compress = T)
  }
}else{
  sim_07_07 <- readRDS("~/Cpp/WaveQTL_HMT/data/Simul2_Data/sim2_beta_13_07_07.RDS")
}
```
Summary of gamma proportions which we simulated, at each tying group.
```{r, include = F}
gamma_summaries <- lapply(sim_07_07$results_gamma_seq, function(x){
  resulting_gamma_proportion <- get_gamma_transition_props(eps_no_scale_data = x[-1]
                                                           ,tying_grp_vect = p_tying_grp
                                                           ,n_pheno = p_n_pheno)
  resulting_gamma_proportion[,c("sim_eps_11","sim_eps_10") :=
                               .(`11`/(`11`+`01`)
                                 ,`10`/(`10`+`00`))]
})
eps_11_summary <- matrix(unlist(lapply(gamma_summaries,function(x){x[,"sim_eps_11"]})),nrow = p_num_sims, ncol = nrow(gamma_summaries[[1]]),byrow = T)
empirical_eps_11_mean <- apply(eps_11_summary,2,mean)
eps_10_summary <- matrix(unlist(lapply(gamma_summaries,function(x){x[,"sim_eps_10"]})),nrow = p_num_sims, ncol = nrow(gamma_summaries[[1]]),byrow = T)
empirical_eps_10_mean <- apply(eps_10_summary,2,mean)
```

Analysis of results from 0.7/0.7 simulation, using 3 $\times$ standard deviation as the bounds here.
```{r, echo = F}
# Plots of the simulated data.

# Sample - one simulation's gamma sequence and y values
sim_number <- 20
g_sample <- tree_plot(sim_07_07$results_gamma_seq[[sim_number]],yaxis_lims = c(0,1), plot_title = paste0("Simulated gamma sequence - simulation ",sim_number))
y_avg_sample <- apply(sim_07_07$results_y_mtx[[sim_number]],MARGIN = 2,mean)
y_avg_sample_plot <- tree_plot(y_avg_sample
                               ,yaxis_lims = c(min(y_avg_sample)
                                               ,max(y_avg_sample)), plot_title = paste0("Simulated y value - simulation ",sim_number))
graphics.off()

# Calculations
pi_mean <- mean(unlist(sim_07_07$results_pi))
pi_sd <- sd(unlist(sim_07_07$results_pi))
pi_range <- c(pi_mean - 3*pi_sd, pi_mean + 3*pi_sd)

results_eps_11_mtx <- matrix(unlist(sim_07_07$results_eps_11)
                             ,nrow = p_num_sims, ncol = (p_n_pheno - 2), byrow = T)
results_eps_10_mtx <- matrix(unlist(sim_07_07$results_eps_10)
                             ,nrow = p_num_sims, ncol = (p_n_pheno - 2), byrow = T)

eps_11_mean <- apply(results_eps_11_mtx,MARGIN = 2,mean)
eps_11_sd <- apply(results_eps_11_mtx,MARGIN = 2,sd)
eps_11_lb <- eps_11_mean - 3*eps_11_sd
eps_11_ub <- eps_11_mean + 3*eps_11_sd

eps_10_mean <- apply(results_eps_10_mtx,MARGIN = 2,mean)
eps_10_sd <- apply(results_eps_10_mtx,MARGIN = 2,sd)
eps_10_lb <- eps_10_mean - 3*eps_10_sd
eps_10_ub <- eps_10_mean + 3*eps_10_sd

# Set up empirical epsilons for comparison
empirical_eps_11 <- c(rep(empirical_eps_11_mean[1],2)) # top two of tree
empirical_eps_10 <- c(rep(empirical_eps_10_mean[1],2)) # top two of tree
for(i in 3:(length(p_tying_grp)-1)){
  st <- p_tying_grp[i]
  end <- p_tying_grp[i+1]-1
  empirical_eps_11[st:end] <- empirical_eps_11[i-2]
  empirical_eps_10[st:end] <- empirical_eps_10[i-2]
}
empirical_eps_11[(end + 1):p_n_pheno] <- empirical_eps_11_mean[i-1]
empirical_eps_10[(end + 1):p_n_pheno] <- empirical_eps_10_mean[i-1]

# Plots
# Epsilon 11
y_axis_bounds <- c(min(min(eps_11_lb),min(sim_07_07$param_eps_11)),max(max(eps_11_ub),max(sim_07_07$param_eps_11)))*1.1

xval = 3:p_n_pheno
which_in_bound = xval[between(sim_07_07$param_eps_11,eps_11_lb,eps_11_ub)]

plot(1,1, type = "n", xlab = "Wavelet scale-loc", ylab = "Probability", main = "Epsilon 11", xaxt = "n"
     ,xlim = c(3,p_n_pheno)
     ,ylim = y_axis_bounds)
if(length(which_in_bound) > 0){
  for(j in 1:length(which_in_bound)){
    polygon(c(which_in_bound[j]-0.5, which_in_bound[j]-0.5, which_in_bound[j]+0.5, which_in_bound[j]+0.5), c(y_axis_bounds[1], y_axis_bounds[2],  y_axis_bounds[2],  y_axis_bounds[1])
            , col ="pink", border = NA)
  }
}

axis(1,at = 2^(3:10),labels = 2^(3:10),las = 2)
points(x = xval, y = sim_07_07$param_eps_11,type = "l")
points(x = xval, empirical_eps_11[-c(1:2)],col = "green", type = "l")
points(x = xval, eps_11_mean,col = "red", type = "l")
points(x = xval, eps_11_ub,col = "blue", type = "l", lty = 2)
points(x = xval, eps_11_lb,col = "blue", type = "l", lty = 2)
legend("topright"
       ,inset = 0.02
       ,legend = c("Input","Simulated (avg)","Estimated (avg)")
       ,title = "Epsilon"
       ,col = c("Black","Green","Red")
       ,lty = rep(1,3)
       ,cex = 0.6
       ,bty = "n"
       ,box.lty = 0)

# Epsilon 10
y_axis_bounds <- c(min(min(eps_10_lb),min(sim_07_07$param_eps_10)),max(max(eps_10_ub),max(sim_07_07$param_eps_10)))*1.1

xval = 3:p_n_pheno
which_in_bound = xval[between(sim_07_07$param_eps_10,eps_10_lb,eps_10_ub)]

plot(1,1, type = "n", xlab = "Wavelet scale-loc", ylab = "Probability", main = "Epsilon 10", xaxt = "n"
     ,xlim = c(3,p_n_pheno)
     ,ylim = y_axis_bounds)
if(length(which_in_bound) > 0){
  for(j in 1:length(which_in_bound)){
    polygon(c(which_in_bound[j]-0.5, which_in_bound[j]-0.5, which_in_bound[j]+0.5, which_in_bound[j]+0.5), c(y_axis_bounds[1], y_axis_bounds[2],  y_axis_bounds[2],  y_axis_bounds[1])
            , col ="pink", border = NA)
  }
}

axis(1,at = 2^(3:10),labels = 2^(3:10),las = 2)
points(x = xval, y = sim_07_07$param_eps_10,type = "l")
points(x = xval, empirical_eps_10[-c(1:2)],col = "green", type = "l")
points(x = xval, eps_10_mean,col = "red", type = "l")
points(x = xval, eps_10_ub,col = "blue", type = "l", lty = 2)
points(x = xval, eps_10_lb,col = "blue", type = "l", lty = 2)
legend("topright"
       ,inset = 0.02
       ,legend = c("Input","Simulated (avg)","Estimated (avg)")
       ,title = "Epsilon"
       ,col = c("Black","Green","Red")
       ,lty = rep(1,3)
       ,cex = 0.6
       ,bty = "n"
       ,box.lty = 0)
```

### 0.5/0.5
```{r, include = FALSE}
p_grped_eps_11 = c(rep(0.5,(length(p_tying_grp)-1)),0)
p_grped_eps_10 = c(rep(0.5,(length(p_tying_grp)-1)),0)

if(run_sims){
  sim_05_05 <- run_sim2(
  n_ind = p_n_ind
  ,n_pheno = p_n_pheno
  ,tying_grp = p_tying_grp
  ,param_pi_00 = p_param_pi_00
  ,param_pi_11 = p_param_pi_11
  ,grped_eps_11 = p_grped_eps_11
  ,grped_eps_10 = p_grped_eps_10
  ,coeff_mu = p_coeff_mu
  ,coeff_beta = p_coeff_beta
  ,param_gi_prob = p_param_gi_prob
  ,param_sigma_beta = p_param_sigma_beta
  ,num_sims = p_num_sims
  ,seed = p_seed)
  if(save_sims & overwrite_data){
    saveRDS(sim_05_05, "~/Cpp/WaveQTL_HMT/data/Simul2_Data/sim2_beta_13_05_05.RDS", compress = T)
  }
}else{
  sim_05_05 <- readRDS("~/Cpp/WaveQTL_HMT/data/Simul2_Data/sim2_beta_13_05_05.RDS")
}
```
Summary of gamma proportions which we simulated, at each tying group.
```{r, include = F}
gamma_summaries <- lapply(sim_05_05$results_gamma_seq, function(x){
  resulting_gamma_proportion <- get_gamma_transition_props(eps_no_scale_data = x[-1]
                                                           ,tying_grp_vect = p_tying_grp
                                                           ,n_pheno = p_n_pheno)
  resulting_gamma_proportion[,c("sim_eps_11","sim_eps_10") :=
                               .(`11`/(`11`+`01`)
                                 ,`10`/(`10`+`00`))]
})
eps_11_summary <- matrix(unlist(lapply(gamma_summaries,function(x){x[,"sim_eps_11"]})),nrow = p_num_sims, ncol = nrow(gamma_summaries[[1]]),byrow = T)
empirical_eps_11_mean <- apply(eps_11_summary,2,mean)
eps_10_summary <- matrix(unlist(lapply(gamma_summaries,function(x){x[,"sim_eps_10"]})),nrow = p_num_sims, ncol = nrow(gamma_summaries[[1]]),byrow = T)
empirical_eps_10_mean <- apply(eps_10_summary,2,mean)
```

Analysis of results from 0.5/0.5 simulation, using 3 $\times$ standard deviation as the bounds here.
```{r, echo = F}
# Plots of the simulated data.

# Sample - one simulation's gamma sequence and y values
sim_number <- 20
g_sample <- tree_plot(sim_05_05$results_gamma_seq[[sim_number]],yaxis_lims = c(0,1), plot_title = paste0("Simulated gamma sequence - simulation ",sim_number))
y_avg_sample <- apply(sim_05_05$results_y_mtx[[sim_number]],MARGIN = 2,mean)
y_avg_sample_plot <- tree_plot(y_avg_sample
                               ,yaxis_lims = c(min(y_avg_sample)
                                               ,max(y_avg_sample)), plot_title = paste0("Simulated y value - simulation ",sim_number))
graphics.off()

# Calculations
pi_mean <- mean(unlist(sim_05_05$results_pi))
pi_sd <- sd(unlist(sim_05_05$results_pi))
pi_range <- c(pi_mean - 3*pi_sd, pi_mean + 3*pi_sd)

results_eps_11_mtx <- matrix(unlist(sim_05_05$results_eps_11)
                             ,nrow = p_num_sims, ncol = (p_n_pheno - 2), byrow = T)
results_eps_10_mtx <- matrix(unlist(sim_05_05$results_eps_10)
                             ,nrow = p_num_sims, ncol = (p_n_pheno - 2), byrow = T)

eps_11_mean <- apply(results_eps_11_mtx,MARGIN = 2,mean)
eps_11_sd <- apply(results_eps_11_mtx,MARGIN = 2,sd)
eps_11_lb <- eps_11_mean - 3*eps_11_sd
eps_11_ub <- eps_11_mean + 3*eps_11_sd

eps_10_mean <- apply(results_eps_10_mtx,MARGIN = 2,mean)
eps_10_sd <- apply(results_eps_10_mtx,MARGIN = 2,sd)
eps_10_lb <- eps_10_mean - 3*eps_10_sd
eps_10_ub <- eps_10_mean + 3*eps_10_sd

# Set up empirical epsilons for comparison
empirical_eps_11 <- c(rep(empirical_eps_11_mean[1],2)) # top two of tree
empirical_eps_10 <- c(rep(empirical_eps_10_mean[1],2)) # top two of tree
for(i in 3:(length(p_tying_grp)-1)){
  st <- p_tying_grp[i]
  end <- p_tying_grp[i+1]-1
  empirical_eps_11[st:end] <- empirical_eps_11[i-2]
  empirical_eps_10[st:end] <- empirical_eps_10[i-2]
}
empirical_eps_11[(end + 1):p_n_pheno] <- empirical_eps_11_mean[i-1]
empirical_eps_10[(end + 1):p_n_pheno] <- empirical_eps_10_mean[i-1]

# Plots
# Epsilon 11
y_axis_bounds <- c(min(min(eps_11_lb),min(sim_05_05$param_eps_11)),max(max(eps_11_ub),max(sim_05_05$param_eps_11)))*1.1

xval = 3:p_n_pheno
which_in_bound = xval[between(sim_05_05$param_eps_11,eps_11_lb,eps_11_ub)]

plot(1,1, type = "n", xlab = "Wavelet scale-loc", ylab = "Probability", main = "Epsilon 11", xaxt = "n"
     ,xlim = c(3,p_n_pheno)
     ,ylim = y_axis_bounds)
if(length(which_in_bound) > 0){
  for(j in 1:length(which_in_bound)){
    polygon(c(which_in_bound[j]-0.5, which_in_bound[j]-0.5, which_in_bound[j]+0.5, which_in_bound[j]+0.5), c(y_axis_bounds[1], y_axis_bounds[2],  y_axis_bounds[2],  y_axis_bounds[1])
            , col ="pink", border = NA)
  }
}

axis(1,at = 2^(3:10),labels = 2^(3:10),las = 2)
points(x = xval, y = sim_05_05$param_eps_11,type = "l")
points(x = xval, empirical_eps_11[-c(1:2)],col = "green", type = "l")
points(x = xval, eps_11_mean,col = "red", type = "l")
points(x = xval, eps_11_ub,col = "blue", type = "l", lty = 2)
points(x = xval, eps_11_lb,col = "blue", type = "l", lty = 2)
legend("topright"
       ,inset = 0.02
       ,legend = c("Input","Simulated (avg)","Estimated (avg)")
       ,title = "Epsilon"
       ,col = c("Black","Green","Red")
       ,lty = rep(1,3)
       ,cex = 0.6
       ,bty = "n"
       ,box.lty = 0)

# Epsilon 10
y_axis_bounds <- c(min(min(eps_10_lb),min(sim_05_05$param_eps_10)),max(max(eps_10_ub),max(sim_05_05$param_eps_10)))*1.1

xval = 3:p_n_pheno
which_in_bound = xval[between(sim_05_05$param_eps_10,eps_10_lb,eps_10_ub)]

plot(1,1, type = "n", xlab = "Wavelet scale-loc", ylab = "Probability", main = "Epsilon 10", xaxt = "n"
     ,xlim = c(3,p_n_pheno)
     ,ylim = y_axis_bounds)
if(length(which_in_bound) > 0){
  for(j in 1:length(which_in_bound)){
    polygon(c(which_in_bound[j]-0.5, which_in_bound[j]-0.5, which_in_bound[j]+0.5, which_in_bound[j]+0.5), c(y_axis_bounds[1], y_axis_bounds[2],  y_axis_bounds[2],  y_axis_bounds[1])
            , col ="pink", border = NA)
  }
}

axis(1,at = 2^(3:10),labels = 2^(3:10),las = 2)
points(x = xval, y = sim_05_05$param_eps_10,type = "l")
points(x = xval, empirical_eps_10[-c(1:2)],col = "green", type = "l")
points(x = xval, eps_10_mean,col = "red", type = "l")
points(x = xval, eps_10_ub,col = "blue", type = "l", lty = 2)
points(x = xval, eps_10_lb,col = "blue", type = "l", lty = 2)
legend("topright"
       ,inset = 0.02
       ,legend = c("Input","Simulated (avg)","Estimated (avg)")
       ,title = "Epsilon"
       ,col = c("Black","Green","Red")
       ,lty = rep(1,3)
       ,cex = 0.6
       ,bty = "n"
       ,box.lty = 0)
```

## Beta = 0.9
```{r}
p_coeff_beta = 0.9 # Beta
```

### 0.8/0.2
```{r, include = FALSE}
p_grped_eps_11 = c(rep(0.8,(length(p_tying_grp)-1)),0)
p_grped_eps_10 = c(rep(0.2,(length(p_tying_grp)-1)),0)

if(run_sims){
  sim_08_02 <- run_sim2(
  n_ind = p_n_ind
  ,n_pheno = p_n_pheno
  ,tying_grp = p_tying_grp
  ,param_pi_00 = p_param_pi_00
  ,param_pi_11 = p_param_pi_11
  ,grped_eps_11 = p_grped_eps_11
  ,grped_eps_10 = p_grped_eps_10
  ,coeff_mu = p_coeff_mu
  ,coeff_beta = p_coeff_beta
  ,param_gi_prob = p_param_gi_prob
  ,param_sigma_beta = p_param_sigma_beta
  ,num_sims = p_num_sims
  ,seed = p_seed)
  if(save_sims & overwrite_data){
    saveRDS(sim_08_02, "~/Cpp/WaveQTL_HMT/data/Simul2_Data/sim2_beta_09_08_02.RDS", compress = T)
  }
}else{
  sim_08_02 <- readRDS("~/Cpp/WaveQTL_HMT/data/Simul2_Data/sim2_beta_09_08_02.RDS")
}

```
Summary of gamma proportions which we simulated, at each tying group.
```{r, include = F}
gamma_summaries <- lapply(sim_08_02$results_gamma_seq, function(x){
  resulting_gamma_proportion <- get_gamma_transition_props(eps_no_scale_data = x[-1]
                                                           ,tying_grp_vect = p_tying_grp
                                                           ,n_pheno = p_n_pheno)
  resulting_gamma_proportion[,c("sim_eps_11","sim_eps_10") :=
                               .(`11`/(`11`+`01`)
                                 ,`10`/(`10`+`00`))]
})
eps_11_summary <- matrix(unlist(lapply(gamma_summaries,function(x){x[,"sim_eps_11"]})),nrow = p_num_sims, ncol = nrow(gamma_summaries[[1]]),byrow = T)
empirical_eps_11_mean <- apply(eps_11_summary,2,mean)
eps_10_summary <- matrix(unlist(lapply(gamma_summaries,function(x){x[,"sim_eps_10"]})),nrow = p_num_sims, ncol = nrow(gamma_summaries[[1]]),byrow = T)
empirical_eps_10_mean <- apply(eps_10_summary,2,mean)
```

Analysis of results from 0.8/0.2 simulation, using 3 $\times$ standard deviation as the bounds here.
```{r, echo = F}
# Plots of the simulated data.

# Sample - one simulation's gamma sequence and y values
sim_number <- 20
g_sample <- tree_plot(sim_08_02$results_gamma_seq[[sim_number]],yaxis_lims = c(0,1), plot_title = paste0("Simulated gamma sequence - simulation ",sim_number))
y_avg_sample <- apply(sim_08_02$results_y_mtx[[sim_number]],MARGIN = 2,mean)
y_avg_sample_plot <- tree_plot(y_avg_sample
                               ,yaxis_lims = c(min(y_avg_sample)
                                               ,max(y_avg_sample)), plot_title = paste0("Simulated y value - simulation ",sim_number))
graphics.off()

# Calculations
pi_mean <- mean(unlist(sim_08_02$results_pi))
pi_sd <- sd(unlist(sim_08_02$results_pi))
pi_range <- c(pi_mean - 3*pi_sd, pi_mean + 3*pi_sd)

results_eps_11_mtx <- matrix(unlist(sim_08_02$results_eps_11)
                             ,nrow = p_num_sims, ncol = (p_n_pheno - 2), byrow = T)
results_eps_10_mtx <- matrix(unlist(sim_08_02$results_eps_10)
                             ,nrow = p_num_sims, ncol = (p_n_pheno - 2), byrow = T)

eps_11_mean <- apply(results_eps_11_mtx,MARGIN = 2,mean)
eps_11_sd <- apply(results_eps_11_mtx,MARGIN = 2,sd)
eps_11_lb <- eps_11_mean - 3*eps_11_sd
eps_11_ub <- eps_11_mean + 3*eps_11_sd

eps_10_mean <- apply(results_eps_10_mtx,MARGIN = 2,mean)
eps_10_sd <- apply(results_eps_10_mtx,MARGIN = 2,sd)
eps_10_lb <- eps_10_mean - 3*eps_10_sd
eps_10_ub <- eps_10_mean + 3*eps_10_sd

# Set up empirical epsilons for comparison
empirical_eps_11 <- c(rep(empirical_eps_11_mean[1],2)) # top two of tree
empirical_eps_10 <- c(rep(empirical_eps_10_mean[1],2)) # top two of tree
for(i in 3:(length(p_tying_grp)-1)){
  st <- p_tying_grp[i]
  end <- p_tying_grp[i+1]-1
  empirical_eps_11[st:end] <- empirical_eps_11[i-2]
  empirical_eps_10[st:end] <- empirical_eps_10[i-2]
}
empirical_eps_11[(end + 1):p_n_pheno] <- empirical_eps_11_mean[i-1]
empirical_eps_10[(end + 1):p_n_pheno] <- empirical_eps_10_mean[i-1]

# Plots
# Epsilon 11
y_axis_bounds <- c(min(min(eps_11_lb),min(sim_08_02$param_eps_11)),max(max(eps_11_ub),max(sim_08_02$param_eps_11)))*1.1

xval = 3:p_n_pheno
which_in_bound = xval[between(sim_08_02$param_eps_11,eps_11_lb,eps_11_ub)]

plot(1,1, type = "n", xlab = "Wavelet scale-loc", ylab = "Probability", main = "Epsilon 11", xaxt = "n"
     ,xlim = c(3,p_n_pheno)
     ,ylim = y_axis_bounds)
if(length(which_in_bound) > 0){
  for(j in 1:length(which_in_bound)){
    polygon(c(which_in_bound[j]-0.5, which_in_bound[j]-0.5, which_in_bound[j]+0.5, which_in_bound[j]+0.5), c(y_axis_bounds[1], y_axis_bounds[2],  y_axis_bounds[2],  y_axis_bounds[1])
            , col ="pink", border = NA)
  }
}

axis(1,at = 2^(3:10),labels = 2^(3:10),las = 2)
points(x = xval, y = sim_08_02$param_eps_11,type = "l")
points(x = xval, empirical_eps_11[-c(1:2)],col = "green", type = "l")
points(x = xval, eps_11_mean,col = "red", type = "l")
points(x = xval, eps_11_ub,col = "blue", type = "l", lty = 2)
points(x = xval, eps_11_lb,col = "blue", type = "l", lty = 2)
legend("topright"
       ,inset = 0.02
       ,legend = c("Input","Simulated (avg)","Estimated (avg)")
       ,title = "Epsilon"
       ,col = c("Black","Green","Red")
       ,lty = rep(1,3)
       ,cex = 0.6
       ,bty = "n"
       ,box.lty = 0)

# Epsilon 10
y_axis_bounds <- c(min(min(eps_10_lb),min(sim_08_02$param_eps_10)),max(max(eps_10_ub),max(sim_08_02$param_eps_10)))*1.1

xval = 3:p_n_pheno
which_in_bound = xval[between(sim_08_02$param_eps_10,eps_10_lb,eps_10_ub)]

plot(1,1, type = "n", xlab = "Wavelet scale-loc", ylab = "Probability", main = "Epsilon 10", xaxt = "n"
     ,xlim = c(3,p_n_pheno)
     ,ylim = y_axis_bounds)
if(length(which_in_bound) > 0){
  for(j in 1:length(which_in_bound)){
    polygon(c(which_in_bound[j]-0.5, which_in_bound[j]-0.5, which_in_bound[j]+0.5, which_in_bound[j]+0.5), c(y_axis_bounds[1], y_axis_bounds[2],  y_axis_bounds[2],  y_axis_bounds[1])
            , col ="pink", border = NA)
  }
}

axis(1,at = 2^(3:10),labels = 2^(3:10),las = 2)
points(x = xval, y = sim_08_02$param_eps_10,type = "l")
points(x = xval, empirical_eps_10[-c(1:2)],col = "green", type = "l")
points(x = xval, eps_10_mean,col = "red", type = "l")
points(x = xval, eps_10_ub,col = "blue", type = "l", lty = 2)
points(x = xval, eps_10_lb,col = "blue", type = "l", lty = 2)
legend("topright"
       ,inset = 0.02
       ,legend = c("Input","Simulated (avg)","Estimated (avg)")
       ,title = "Epsilon"
       ,col = c("Black","Green","Red")
       ,lty = rep(1,3)
       ,cex = 0.6
       ,bty = "n"
       ,box.lty = 0)
```

### 0.7/0.3
```{r, include = FALSE}
p_grped_eps_11 = c(rep(0.7,(length(p_tying_grp)-1)),0)
p_grped_eps_10 = c(rep(0.3,(length(p_tying_grp)-1)),0)

if(run_sims){
  sim_07_03 <- run_sim2(
  n_ind = p_n_ind
  ,n_pheno = p_n_pheno
  ,tying_grp = p_tying_grp
  ,param_pi_00 = p_param_pi_00
  ,param_pi_11 = p_param_pi_11
  ,grped_eps_11 = p_grped_eps_11
  ,grped_eps_10 = p_grped_eps_10
  ,coeff_mu = p_coeff_mu
  ,coeff_beta = p_coeff_beta
  ,param_gi_prob = p_param_gi_prob
  ,param_sigma_beta = p_param_sigma_beta
  ,num_sims = p_num_sims
  ,seed = p_seed)
  if(save_sims & overwrite_data){
    saveRDS(sim_07_03, "~/Cpp/WaveQTL_HMT/data/Simul2_Data/sim2_beta_09_07_03.RDS", compress = T)
  }
}else{
  sim_07_03 <- readRDS("~/Cpp/WaveQTL_HMT/data/Simul2_Data/sim2_beta_09_07_03.RDS")
}
```
Summary of gamma proportions which we simulated, at each tying group.
```{r, include = F}
gamma_summaries <- lapply(sim_07_03$results_gamma_seq, function(x){
  resulting_gamma_proportion <- get_gamma_transition_props(eps_no_scale_data = x[-1]
                                                           ,tying_grp_vect = p_tying_grp
                                                           ,n_pheno = p_n_pheno)
  resulting_gamma_proportion[,c("sim_eps_11","sim_eps_10") :=
                               .(`11`/(`11`+`01`)
                                 ,`10`/(`10`+`00`))]
})
eps_11_summary <- matrix(unlist(lapply(gamma_summaries,function(x){x[,"sim_eps_11"]})),nrow = p_num_sims, ncol = nrow(gamma_summaries[[1]]),byrow = T)
empirical_eps_11_mean <- apply(eps_11_summary,2,mean)
eps_10_summary <- matrix(unlist(lapply(gamma_summaries,function(x){x[,"sim_eps_10"]})),nrow = p_num_sims, ncol = nrow(gamma_summaries[[1]]),byrow = T)
empirical_eps_10_mean <- apply(eps_10_summary,2,mean)
```

Analysis of results from 0.7/0.3 simulation, using 3 $\times$ standard deviation as the bounds here.
```{r, echo = F}
# Plots of the simulated data.

# Sample - one simulation's gamma sequence and y values
sim_number <- 20
g_sample <- tree_plot(sim_07_03$results_gamma_seq[[sim_number]],yaxis_lims = c(0,1), plot_title = paste0("Simulated gamma sequence - simulation ",sim_number))
y_avg_sample <- apply(sim_07_03$results_y_mtx[[sim_number]],MARGIN = 2,mean)
y_avg_sample_plot <- tree_plot(y_avg_sample
                               ,yaxis_lims = c(min(y_avg_sample)
                                               ,max(y_avg_sample)), plot_title = paste0("Simulated y value - simulation ",sim_number))
graphics.off()

# Calculations
pi_mean <- mean(unlist(sim_07_03$results_pi))
pi_sd <- sd(unlist(sim_07_03$results_pi))
pi_range <- c(pi_mean - 3*pi_sd, pi_mean + 3*pi_sd)

results_eps_11_mtx <- matrix(unlist(sim_07_03$results_eps_11)
                             ,nrow = p_num_sims, ncol = (p_n_pheno - 2), byrow = T)
results_eps_10_mtx <- matrix(unlist(sim_07_03$results_eps_10)
                             ,nrow = p_num_sims, ncol = (p_n_pheno - 2), byrow = T)

eps_11_mean <- apply(results_eps_11_mtx,MARGIN = 2,mean)
eps_11_sd <- apply(results_eps_11_mtx,MARGIN = 2,sd)
eps_11_lb <- eps_11_mean - 3*eps_11_sd
eps_11_ub <- eps_11_mean + 3*eps_11_sd

eps_10_mean <- apply(results_eps_10_mtx,MARGIN = 2,mean)
eps_10_sd <- apply(results_eps_10_mtx,MARGIN = 2,sd)
eps_10_lb <- eps_10_mean - 3*eps_10_sd
eps_10_ub <- eps_10_mean + 3*eps_10_sd

# Set up empirical epsilons for comparison
empirical_eps_11 <- c(rep(empirical_eps_11_mean[1],2)) # top two of tree
empirical_eps_10 <- c(rep(empirical_eps_10_mean[1],2)) # top two of tree
for(i in 3:(length(p_tying_grp)-1)){
  st <- p_tying_grp[i]
  end <- p_tying_grp[i+1]-1
  empirical_eps_11[st:end] <- empirical_eps_11[i-2]
  empirical_eps_10[st:end] <- empirical_eps_10[i-2]
}
empirical_eps_11[(end + 1):p_n_pheno] <- empirical_eps_11_mean[i-1]
empirical_eps_10[(end + 1):p_n_pheno] <- empirical_eps_10_mean[i-1]

# Plots
# Epsilon 11
y_axis_bounds <- c(min(min(eps_11_lb),min(sim_07_03$param_eps_11)),max(max(eps_11_ub),max(sim_07_03$param_eps_11)))*1.1

xval = 3:p_n_pheno
which_in_bound = xval[between(sim_07_03$param_eps_11,eps_11_lb,eps_11_ub)]

plot(1,1, type = "n", xlab = "Wavelet scale-loc", ylab = "Probability", main = "Epsilon 11", xaxt = "n"
     ,xlim = c(3,p_n_pheno)
     ,ylim = y_axis_bounds)
if(length(which_in_bound) > 0){
  for(j in 1:length(which_in_bound)){
    polygon(c(which_in_bound[j]-0.5, which_in_bound[j]-0.5, which_in_bound[j]+0.5, which_in_bound[j]+0.5), c(y_axis_bounds[1], y_axis_bounds[2],  y_axis_bounds[2],  y_axis_bounds[1])
            , col ="pink", border = NA)
  }
}

axis(1,at = 2^(3:10),labels = 2^(3:10),las = 2)
points(x = xval, y = sim_07_03$param_eps_11,type = "l")
points(x = xval, empirical_eps_11[-c(1:2)],col = "green", type = "l")
points(x = xval, eps_11_mean,col = "red", type = "l")
points(x = xval, eps_11_ub,col = "blue", type = "l", lty = 2)
points(x = xval, eps_11_lb,col = "blue", type = "l", lty = 2)
legend("topright"
       ,inset = 0.02
       ,legend = c("Input","Simulated (avg)","Estimated (avg)")
       ,title = "Epsilon"
       ,col = c("Black","Green","Red")
       ,lty = rep(1,3)
       ,cex = 0.6
       ,bty = "n"
       ,box.lty = 0)

# Epsilon 10
y_axis_bounds <- c(min(min(eps_10_lb),min(sim_07_03$param_eps_10)),max(max(eps_10_ub),max(sim_07_03$param_eps_10)))*1.1

xval = 3:p_n_pheno
which_in_bound = xval[between(sim_07_03$param_eps_10,eps_10_lb,eps_10_ub)]

plot(1,1, type = "n", xlab = "Wavelet scale-loc", ylab = "Probability", main = "Epsilon 10", xaxt = "n"
     ,xlim = c(3,p_n_pheno)
     ,ylim = y_axis_bounds)
if(length(which_in_bound) > 0){
  for(j in 1:length(which_in_bound)){
    polygon(c(which_in_bound[j]-0.5, which_in_bound[j]-0.5, which_in_bound[j]+0.5, which_in_bound[j]+0.5), c(y_axis_bounds[1], y_axis_bounds[2],  y_axis_bounds[2],  y_axis_bounds[1])
            , col ="pink", border = NA)
  }
}

axis(1,at = 2^(3:10),labels = 2^(3:10),las = 2)
points(x = xval, y = sim_07_03$param_eps_10,type = "l")
points(x = xval, empirical_eps_10[-c(1:2)],col = "green", type = "l")
points(x = xval, eps_10_mean,col = "red", type = "l")
points(x = xval, eps_10_ub,col = "blue", type = "l", lty = 2)
points(x = xval, eps_10_lb,col = "blue", type = "l", lty = 2)
legend("topright"
       ,inset = 0.02
       ,legend = c("Input","Simulated (avg)","Estimated (avg)")
       ,title = "Epsilon"
       ,col = c("Black","Green","Red")
       ,lty = rep(1,3)
       ,cex = 0.6
       ,bty = "n"
       ,box.lty = 0)
```

### 0.7/0.7
```{r, include = FALSE}
p_grped_eps_11 = c(rep(0.7,(length(p_tying_grp)-1)),0)
p_grped_eps_10 = c(rep(0.7,(length(p_tying_grp)-1)),0)

if(run_sims){
  sim_07_07 <- run_sim2(
  n_ind = p_n_ind
  ,n_pheno = p_n_pheno
  ,tying_grp = p_tying_grp
  ,param_pi_00 = p_param_pi_00
  ,param_pi_11 = p_param_pi_11
  ,grped_eps_11 = p_grped_eps_11
  ,grped_eps_10 = p_grped_eps_10
  ,coeff_mu = p_coeff_mu
  ,coeff_beta = p_coeff_beta
  ,param_gi_prob = p_param_gi_prob
  ,param_sigma_beta = p_param_sigma_beta
  ,num_sims = p_num_sims
  ,seed = p_seed)
  if(save_sims & overwrite_data){
    saveRDS(sim_07_07, "~/Cpp/WaveQTL_HMT/data/Simul2_Data/sim2_beta_09_07_07.RDS", compress = T)
  }
}else{
  sim_07_07 <- readRDS("~/Cpp/WaveQTL_HMT/data/Simul2_Data/sim2_beta_09_07_07.RDS")
}
```
Summary of gamma proportions which we simulated, at each tying group.
```{r, include = F}
gamma_summaries <- lapply(sim_07_07$results_gamma_seq, function(x){
  resulting_gamma_proportion <- get_gamma_transition_props(eps_no_scale_data = x[-1]
                                                           ,tying_grp_vect = p_tying_grp
                                                           ,n_pheno = p_n_pheno)
  resulting_gamma_proportion[,c("sim_eps_11","sim_eps_10") :=
                               .(`11`/(`11`+`01`)
                                 ,`10`/(`10`+`00`))]
})
eps_11_summary <- matrix(unlist(lapply(gamma_summaries,function(x){x[,"sim_eps_11"]})),nrow = p_num_sims, ncol = nrow(gamma_summaries[[1]]),byrow = T)
empirical_eps_11_mean <- apply(eps_11_summary,2,mean)
eps_10_summary <- matrix(unlist(lapply(gamma_summaries,function(x){x[,"sim_eps_10"]})),nrow = p_num_sims, ncol = nrow(gamma_summaries[[1]]),byrow = T)
empirical_eps_10_mean <- apply(eps_10_summary,2,mean)
```

Analysis of results from 0.7/0.7 simulation, using 3 $\times$ standard deviation as the bounds here.
```{r, echo = F}
# Plots of the simulated data.

# Sample - one simulation's gamma sequence and y values
sim_number <- 20
g_sample <- tree_plot(sim_07_07$results_gamma_seq[[sim_number]],yaxis_lims = c(0,1), plot_title = paste0("Simulated gamma sequence - simulation ",sim_number))
y_avg_sample <- apply(sim_07_07$results_y_mtx[[sim_number]],MARGIN = 2,mean)
y_avg_sample_plot <- tree_plot(y_avg_sample
                               ,yaxis_lims = c(min(y_avg_sample)
                                               ,max(y_avg_sample)), plot_title = paste0("Simulated y value - simulation ",sim_number))
graphics.off()

# Calculations
pi_mean <- mean(unlist(sim_07_07$results_pi))
pi_sd <- sd(unlist(sim_07_07$results_pi))
pi_range <- c(pi_mean - 3*pi_sd, pi_mean + 3*pi_sd)

results_eps_11_mtx <- matrix(unlist(sim_07_07$results_eps_11)
                             ,nrow = p_num_sims, ncol = (p_n_pheno - 2), byrow = T)
results_eps_10_mtx <- matrix(unlist(sim_07_07$results_eps_10)
                             ,nrow = p_num_sims, ncol = (p_n_pheno - 2), byrow = T)

eps_11_mean <- apply(results_eps_11_mtx,MARGIN = 2,mean)
eps_11_sd <- apply(results_eps_11_mtx,MARGIN = 2,sd)
eps_11_lb <- eps_11_mean - 3*eps_11_sd
eps_11_ub <- eps_11_mean + 3*eps_11_sd

eps_10_mean <- apply(results_eps_10_mtx,MARGIN = 2,mean)
eps_10_sd <- apply(results_eps_10_mtx,MARGIN = 2,sd)
eps_10_lb <- eps_10_mean - 3*eps_10_sd
eps_10_ub <- eps_10_mean + 3*eps_10_sd

# Set up empirical epsilons for comparison
empirical_eps_11 <- c(rep(empirical_eps_11_mean[1],2)) # top two of tree
empirical_eps_10 <- c(rep(empirical_eps_10_mean[1],2)) # top two of tree
for(i in 3:(length(p_tying_grp)-1)){
  st <- p_tying_grp[i]
  end <- p_tying_grp[i+1]-1
  empirical_eps_11[st:end] <- empirical_eps_11[i-2]
  empirical_eps_10[st:end] <- empirical_eps_10[i-2]
}
empirical_eps_11[(end + 1):p_n_pheno] <- empirical_eps_11_mean[i-1]
empirical_eps_10[(end + 1):p_n_pheno] <- empirical_eps_10_mean[i-1]

# Plots
# Epsilon 11
y_axis_bounds <- c(min(min(eps_11_lb),min(sim_07_07$param_eps_11)),max(max(eps_11_ub),max(sim_07_07$param_eps_11)))*1.1

xval = 3:p_n_pheno
which_in_bound = xval[between(sim_07_07$param_eps_11,eps_11_lb,eps_11_ub)]

plot(1,1, type = "n", xlab = "Wavelet scale-loc", ylab = "Probability", main = "Epsilon 11", xaxt = "n"
     ,xlim = c(3,p_n_pheno)
     ,ylim = y_axis_bounds)
if(length(which_in_bound) > 0){
  for(j in 1:length(which_in_bound)){
    polygon(c(which_in_bound[j]-0.5, which_in_bound[j]-0.5, which_in_bound[j]+0.5, which_in_bound[j]+0.5), c(y_axis_bounds[1], y_axis_bounds[2],  y_axis_bounds[2],  y_axis_bounds[1])
            , col ="pink", border = NA)
  }
}

axis(1,at = 2^(3:10),labels = 2^(3:10),las = 2)
points(x = xval, y = sim_07_07$param_eps_11,type = "l")
points(x = xval, empirical_eps_11[-c(1:2)],col = "green", type = "l")
points(x = xval, eps_11_mean,col = "red", type = "l")
points(x = xval, eps_11_ub,col = "blue", type = "l", lty = 2)
points(x = xval, eps_11_lb,col = "blue", type = "l", lty = 2)
legend("topright"
       ,inset = 0.02
       ,legend = c("Input","Simulated (avg)","Estimated (avg)")
       ,title = "Epsilon"
       ,col = c("Black","Green","Red")
       ,lty = rep(1,3)
       ,cex = 0.6
       ,bty = "n"
       ,box.lty = 0)

# Epsilon 10
y_axis_bounds <- c(min(min(eps_10_lb),min(sim_07_07$param_eps_10)),max(max(eps_10_ub),max(sim_07_07$param_eps_10)))*1.1

xval = 3:p_n_pheno
which_in_bound = xval[between(sim_07_07$param_eps_10,eps_10_lb,eps_10_ub)]

plot(1,1, type = "n", xlab = "Wavelet scale-loc", ylab = "Probability", main = "Epsilon 10", xaxt = "n"
     ,xlim = c(3,p_n_pheno)
     ,ylim = y_axis_bounds)
if(length(which_in_bound) > 0){
  for(j in 1:length(which_in_bound)){
    polygon(c(which_in_bound[j]-0.5, which_in_bound[j]-0.5, which_in_bound[j]+0.5, which_in_bound[j]+0.5), c(y_axis_bounds[1], y_axis_bounds[2],  y_axis_bounds[2],  y_axis_bounds[1])
            , col ="pink", border = NA)
  }
}

axis(1,at = 2^(3:10),labels = 2^(3:10),las = 2)
points(x = xval, y = sim_07_07$param_eps_10,type = "l")
points(x = xval, empirical_eps_10[-c(1:2)],col = "green", type = "l")
points(x = xval, eps_10_mean,col = "red", type = "l")
points(x = xval, eps_10_ub,col = "blue", type = "l", lty = 2)
points(x = xval, eps_10_lb,col = "blue", type = "l", lty = 2)
legend("topright"
       ,inset = 0.02
       ,legend = c("Input","Simulated (avg)","Estimated (avg)")
       ,title = "Epsilon"
       ,col = c("Black","Green","Red")
       ,lty = rep(1,3)
       ,cex = 0.6
       ,bty = "n"
       ,box.lty = 0)
```

### 0.5/0.5
```{r, include = FALSE}
p_grped_eps_11 = c(rep(0.5,(length(p_tying_grp)-1)),0)
p_grped_eps_10 = c(rep(0.5,(length(p_tying_grp)-1)),0)

if(run_sims){
  sim_05_05 <- run_sim2(
  n_ind = p_n_ind
  ,n_pheno = p_n_pheno
  ,tying_grp = p_tying_grp
  ,param_pi_00 = p_param_pi_00
  ,param_pi_11 = p_param_pi_11
  ,grped_eps_11 = p_grped_eps_11
  ,grped_eps_10 = p_grped_eps_10
  ,coeff_mu = p_coeff_mu
  ,coeff_beta = p_coeff_beta
  ,param_gi_prob = p_param_gi_prob
  ,param_sigma_beta = p_param_sigma_beta
  ,num_sims = p_num_sims
  ,seed = p_seed)
  if(save_sims & overwrite_data){
    saveRDS(sim_05_05, "~/Cpp/WaveQTL_HMT/data/Simul2_Data/sim2_beta_09_05_05.RDS", compress = T)
  }
}else{
  sim_05_05 <- readRDS("~/Cpp/WaveQTL_HMT/data/Simul2_Data/sim2_beta_09_05_05.RDS")
}
```
Summary of gamma proportions which we simulated, at each tying group.
```{r, include = F}
gamma_summaries <- lapply(sim_05_05$results_gamma_seq, function(x){
  resulting_gamma_proportion <- get_gamma_transition_props(eps_no_scale_data = x[-1]
                                                           ,tying_grp_vect = p_tying_grp
                                                           ,n_pheno = p_n_pheno)
  resulting_gamma_proportion[,c("sim_eps_11","sim_eps_10") :=
                               .(`11`/(`11`+`01`)
                                 ,`10`/(`10`+`00`))]
})
eps_11_summary <- matrix(unlist(lapply(gamma_summaries,function(x){x[,"sim_eps_11"]})),nrow = p_num_sims, ncol = nrow(gamma_summaries[[1]]),byrow = T)
empirical_eps_11_mean <- apply(eps_11_summary,2,mean)
eps_10_summary <- matrix(unlist(lapply(gamma_summaries,function(x){x[,"sim_eps_10"]})),nrow = p_num_sims, ncol = nrow(gamma_summaries[[1]]),byrow = T)
empirical_eps_10_mean <- apply(eps_10_summary,2,mean)
```

Analysis of results from 0.5/0.5 simulation, using 3 $\times$ standard deviation as the bounds here.
```{r, echo = F}
# Plots of the simulated data.

# Sample - one simulation's gamma sequence and y values
sim_number <- 20
g_sample <- tree_plot(sim_05_05$results_gamma_seq[[sim_number]],yaxis_lims = c(0,1), plot_title = paste0("Simulated gamma sequence - simulation ",sim_number))
y_avg_sample <- apply(sim_05_05$results_y_mtx[[sim_number]],MARGIN = 2,mean)
y_avg_sample_plot <- tree_plot(y_avg_sample
                               ,yaxis_lims = c(min(y_avg_sample)
                                               ,max(y_avg_sample)), plot_title = paste0("Simulated y value - simulation ",sim_number))
graphics.off()

# Calculations
pi_mean <- mean(unlist(sim_05_05$results_pi))
pi_sd <- sd(unlist(sim_05_05$results_pi))
pi_range <- c(pi_mean - 3*pi_sd, pi_mean + 3*pi_sd)

results_eps_11_mtx <- matrix(unlist(sim_05_05$results_eps_11)
                             ,nrow = p_num_sims, ncol = (p_n_pheno - 2), byrow = T)
results_eps_10_mtx <- matrix(unlist(sim_05_05$results_eps_10)
                             ,nrow = p_num_sims, ncol = (p_n_pheno - 2), byrow = T)

eps_11_mean <- apply(results_eps_11_mtx,MARGIN = 2,mean)
eps_11_sd <- apply(results_eps_11_mtx,MARGIN = 2,sd)
eps_11_lb <- eps_11_mean - 3*eps_11_sd
eps_11_ub <- eps_11_mean + 3*eps_11_sd

eps_10_mean <- apply(results_eps_10_mtx,MARGIN = 2,mean)
eps_10_sd <- apply(results_eps_10_mtx,MARGIN = 2,sd)
eps_10_lb <- eps_10_mean - 3*eps_10_sd
eps_10_ub <- eps_10_mean + 3*eps_10_sd

# Set up empirical epsilons for comparison
empirical_eps_11 <- c(rep(empirical_eps_11_mean[1],2)) # top two of tree
empirical_eps_10 <- c(rep(empirical_eps_10_mean[1],2)) # top two of tree
for(i in 3:(length(p_tying_grp)-1)){
  st <- p_tying_grp[i]
  end <- p_tying_grp[i+1]-1
  empirical_eps_11[st:end] <- empirical_eps_11[i-2]
  empirical_eps_10[st:end] <- empirical_eps_10[i-2]
}
empirical_eps_11[(end + 1):p_n_pheno] <- empirical_eps_11_mean[i-1]
empirical_eps_10[(end + 1):p_n_pheno] <- empirical_eps_10_mean[i-1]

# Plots
# Epsilon 11
y_axis_bounds <- c(min(min(eps_11_lb),min(sim_05_05$param_eps_11)),max(max(eps_11_ub),max(sim_05_05$param_eps_11)))*1.1

xval = 3:p_n_pheno
which_in_bound = xval[between(sim_05_05$param_eps_11,eps_11_lb,eps_11_ub)]

plot(1,1, type = "n", xlab = "Wavelet scale-loc", ylab = "Probability", main = "Epsilon 11", xaxt = "n"
     ,xlim = c(3,p_n_pheno)
     ,ylim = y_axis_bounds)
if(length(which_in_bound) > 0){
  for(j in 1:length(which_in_bound)){
    polygon(c(which_in_bound[j]-0.5, which_in_bound[j]-0.5, which_in_bound[j]+0.5, which_in_bound[j]+0.5), c(y_axis_bounds[1], y_axis_bounds[2],  y_axis_bounds[2],  y_axis_bounds[1])
            , col ="pink", border = NA)
  }
}

axis(1,at = 2^(3:10),labels = 2^(3:10),las = 2)
points(x = xval, y = sim_05_05$param_eps_11,type = "l")
points(x = xval, empirical_eps_11[-c(1:2)],col = "green", type = "l")
points(x = xval, eps_11_mean,col = "red", type = "l")
points(x = xval, eps_11_ub,col = "blue", type = "l", lty = 2)
points(x = xval, eps_11_lb,col = "blue", type = "l", lty = 2)
legend("topright"
       ,inset = 0.02
       ,legend = c("Input","Simulated (avg)","Estimated (avg)")
       ,title = "Epsilon"
       ,col = c("Black","Green","Red")
       ,lty = rep(1,3)
       ,cex = 0.6
       ,bty = "n"
       ,box.lty = 0)

# Epsilon 10
y_axis_bounds <- c(min(min(eps_10_lb),min(sim_05_05$param_eps_10)),max(max(eps_10_ub),max(sim_05_05$param_eps_10)))*1.1

xval = 3:p_n_pheno
which_in_bound = xval[between(sim_05_05$param_eps_10,eps_10_lb,eps_10_ub)]

plot(1,1, type = "n", xlab = "Wavelet scale-loc", ylab = "Probability", main = "Epsilon 10", xaxt = "n"
     ,xlim = c(3,p_n_pheno)
     ,ylim = y_axis_bounds)
if(length(which_in_bound) > 0){
  for(j in 1:length(which_in_bound)){
    polygon(c(which_in_bound[j]-0.5, which_in_bound[j]-0.5, which_in_bound[j]+0.5, which_in_bound[j]+0.5), c(y_axis_bounds[1], y_axis_bounds[2],  y_axis_bounds[2],  y_axis_bounds[1])
            , col ="pink", border = NA)
  }
}

axis(1,at = 2^(3:10),labels = 2^(3:10),las = 2)
points(x = xval, y = sim_05_05$param_eps_10,type = "l")
points(x = xval, empirical_eps_10[-c(1:2)],col = "green", type = "l")
points(x = xval, eps_10_mean,col = "red", type = "l")
points(x = xval, eps_10_ub,col = "blue", type = "l", lty = 2)
points(x = xval, eps_10_lb,col = "blue", type = "l", lty = 2)
legend("topright"
       ,inset = 0.02
       ,legend = c("Input","Simulated (avg)","Estimated (avg)")
       ,title = "Epsilon"
       ,col = c("Black","Green","Red")
       ,lty = rep(1,3)
       ,cex = 0.6
       ,bty = "n"
       ,box.lty = 0)
```

## Supporting material which won't go in the thesis, but is good to have.

### The beta stress tests
Epsilon 0.7/0.3, for example:
```{r}
p_n_ind = 70
p_n_pheno = 128
p_tying_grp = c(1,2,3,65)
p_param_pi_00 = 0
p_param_pi_11 = 1
p_grped_eps_11 = c(rep(0.7,(length(p_tying_grp)-1)),0)
p_grped_eps_10 = c(rep(0.3,(length(p_tying_grp)-1)),0)
p_coeff_mu = 0
p_param_gi_prob = 0.4
p_param_sigma_beta = 5 # 0.5
p_num_sims = 50
p_seed = 20

sim_results <- list()

betas_to_try <- seq(0,2,0.1)
```

Run the simulations across many betas
```{r, include = F}
n = 1
if(run_sims){
  for(beta_coeff in betas_to_try){
    sim_results[[n]] <- run_sim2(
      n_ind = p_n_ind
      ,n_pheno = p_n_pheno
      ,tying_grp = p_tying_grp
      ,param_pi_00 = p_param_pi_00
      ,param_pi_11 = p_param_pi_11
      ,grped_eps_11 = p_grped_eps_11
      ,grped_eps_10 = p_grped_eps_10
      ,coeff_mu = p_coeff_mu
      ,coeff_beta = beta_coeff
      ,param_gi_prob = p_param_gi_prob
      ,param_sigma_beta = p_param_sigma_beta
      ,num_sims = p_num_sims
      ,seed = p_seed)
    n = n + 1
  }
  if(save_sims & overwrite_data){
    saveRDS(sim_results, "~/Cpp/WaveQTL_HMT/data/Simul2_Data/sim2_beta_sens_07_03.RDS", compress = T)
  }
}else{
  sim_results <- readRDS("~/Cpp/WaveQTL_HMT/data/Simul2_Data/sim2_beta_sens_07_03.RDS")
}


pi_mean_list <- list()
pi_sd_list <- list()
eps_11_mean_list <- list()
eps_11_sd_list <- list()
eps_10_mean_list <- list()
eps_10_sd_list <- list()
for(i in 1:length(sim_results)){
  pi_mean_list[[i]] <- mean(unlist(sim_results[[i]]$results_pi))
  pi_sd_list[[i]] <- sd(unlist(sim_results[[i]]$results_pi))

  results_eps_11_mtx <- matrix(unlist(sim_results[[i]]$results_eps_11)
                               ,nrow = p_num_sims, ncol = (p_n_pheno - 2), byrow = T)
  results_eps_10_mtx <- matrix(unlist(sim_results[[i]]$results_eps_10)
                               ,nrow = p_num_sims, ncol = (p_n_pheno - 2), byrow = T)

  eps_11_mean_list[[i]] <- apply(results_eps_11_mtx,MARGIN = 2,mean)
  eps_11_sd_list[[i]] <- apply(results_eps_11_mtx,MARGIN = 2,sd)
  eps_10_mean_list[[i]] <- apply(results_eps_10_mtx,MARGIN = 2,mean)
  eps_10_sd_list[[i]] <- apply(results_eps_10_mtx,MARGIN = 2,sd)
}
```

Analysis:
```{r}
# Pi
pi_mean_results <- unlist(pi_mean_list)
pi_sd_results <- unlist(pi_sd_list)
y_axis_bounds <- c(min(pi_mean_results - 2*pi_sd_results),max(pi_mean_results + 2*pi_sd_results))
plot(x = betas_to_try
     , y = rep(p_param_pi_11, length(betas_to_try))
     , col = "black"
     , type = "l"
     , xlab = "Beta coeffs"
     , ylab = "Pi estimate"
     , main = "Sensitity of Pi estimate by beta coeff (beta noise = 5, eps_11 = 0.7, eps_10 = 0.3)"
     , xaxt = "n"
     # , xlim = c(min(betas_to_try),max(betas_to_try))
     , ylim = y_axis_bounds)
axis(1,at = betas_to_try,labels = betas_to_try,las = 2)
points(x = betas_to_try, y = pi_mean_results,col = "red", type = "l")
points(x = betas_to_try, y = pi_mean_results + pi_sd_results*2, col = "blue", type = "l")
points(x = betas_to_try, y = pi_mean_results - pi_sd_results*2, col = "blue", type = "l")

# Eps_11
eps_11_means <- sapply(eps_11_mean_list, function(x){
  y <- c(0,0,x)[p_tying_grp]
  return(y)
})
eps_11_sd <- sapply(eps_11_sd_list, function(x){
  y <- c(0,0,x)[p_tying_grp]
  return(y)
})
eps_11_lb <- eps_11_means - 2*eps_11_sd
eps_11_ub <- eps_11_means + 2*eps_11_sd

y_axis_bounds <- c(min(min(eps_11_lb[3,]),min(p_grped_eps_11[3]))
                   ,max(max(eps_11_ub[3,]),max(p_grped_eps_11[3])))*1.1
xval = betas_to_try
which_in_bound = xval[between(p_grped_eps_11[3],eps_11_lb[3,],eps_11_ub[3,])]
plot(1,1, type = "n"
     , xlab = "Beta coeff", ylab = "Eps_11 estimate", main = "Eps_11 estimation sensitivity to beta - grp 2 (beta noise = 5, eps_11 = 0.7, eps_10 = 0.3)"
     , xaxt = "n"
     , xlim = c(min(betas_to_try),max(betas_to_try))
     , ylim = y_axis_bounds)
if(length(which_in_bound) > 0){
  for(j in 1:length(which_in_bound)){
    polygon(c(which_in_bound[j] - 0.05, which_in_bound[j] - 0.05, which_in_bound[j] + 0.05, which_in_bound[j] + 0.05), c(y_axis_bounds[1], y_axis_bounds[2],  y_axis_bounds[2],  y_axis_bounds[1])
            , col ="pink", border = NA)
  }
}
axis(1,at = betas_to_try,labels = betas_to_try,las = 2)
points(x = betas_to_try, y = rep(p_grped_eps_11[3],length(betas_to_try)),type = "l")
points(x = betas_to_try, y = eps_11_means[3,],col = "red", type = "l")
points(x = betas_to_try, y = eps_11_lb[3,],col = "blue", type = "l", lty = 2)
points(x = betas_to_try, y = eps_11_ub[3,],col = "blue", type = "l", lty = 2)

y_axis_bounds <- c(min(min(eps_11_lb[4,]),min(p_grped_eps_11[4]))
                   ,max(max(eps_11_ub[4,]),max(p_grped_eps_11[4])))*1.1
xval = betas_to_try
which_in_bound = xval[between(p_grped_eps_11[4],eps_11_lb[4,],eps_11_ub[4,])]
plot(1,1, type = "n"
     , xlab = "Beta coeff", ylab = "Eps_11 estimate", main = "Eps_11 estimation sensitivity to beta - grp 3 (beta noise = 5, eps_11 = 0.7, eps_10 = 0.3)"
     , xaxt = "n"
     , xlim = c(min(betas_to_try),max(betas_to_try))
     , ylim = y_axis_bounds)
if(length(which_in_bound) > 0){
  for(j in 1:length(which_in_bound)){
    polygon(c(which_in_bound[j] - 0.05, which_in_bound[j] - 0.05, which_in_bound[j] + 0.05, which_in_bound[j] + 0.05), c(y_axis_bounds[1], y_axis_bounds[2],  y_axis_bounds[2],  y_axis_bounds[1])
            , col ="pink", border = NA)
  }
}
axis(1,at = betas_to_try,labels = betas_to_try,las = 2)
points(x = betas_to_try, y = rep(p_grped_eps_11[4],length(betas_to_try)),type = "l")
points(x = betas_to_try, y = eps_11_means[4,],col = "red", type = "l")
points(x = betas_to_try, y = eps_11_lb[4,],col = "blue", type = "l", lty = 2)
points(x = betas_to_try, y = eps_11_ub[4,],col = "blue", type = "l", lty = 2)

# Eps_10
eps_10_means <- sapply(eps_10_mean_list, function(x){
  y <- c(0,0,x)[p_tying_grp]
  return(y)
})
eps_10_sd <- sapply(eps_10_sd_list, function(x){
  y <- c(0,0,x)[p_tying_grp]
  return(y)
})
eps_10_lb <- eps_10_means - 2*eps_10_sd
eps_10_ub <- eps_10_means + 2*eps_10_sd

y_axis_bounds <- c(min(min(eps_10_lb[3,]),min(p_grped_eps_10[3]))
                   ,max(max(eps_10_ub[3,]),max(p_grped_eps_10[3])))*1.1
xval = betas_to_try
which_in_bound = xval[between(p_grped_eps_10[3],eps_10_lb[3,],eps_10_ub[3,])]
plot(1,1, type = "n"
     , xlab = "Beta coeff", ylab = "eps_10 estimate", main = "eps_10 estimation sensitivity to beta - grp 2 (beta noise = 5, eps_11 = 0.7, eps_10 = 0.3)"
     , xaxt = "n"
     , xlim = c(min(betas_to_try),max(betas_to_try))
     , ylim = y_axis_bounds)
if(length(which_in_bound) > 0){
  for(j in 1:length(which_in_bound)){
    polygon(c(which_in_bound[j] - 0.05, which_in_bound[j] - 0.05, which_in_bound[j] + 0.05, which_in_bound[j] + 0.05), c(y_axis_bounds[1], y_axis_bounds[2],  y_axis_bounds[2],  y_axis_bounds[1])
            , col ="pink", border = NA)
  }
}
axis(1,at = betas_to_try,labels = betas_to_try,las = 2)
points(x = betas_to_try, y = rep(p_grped_eps_10[3],length(betas_to_try)),type = "l")
points(x = betas_to_try, y = eps_10_means[3,],col = "red", type = "l")
points(x = betas_to_try, y = eps_10_lb[3,],col = "blue", type = "l", lty = 2)
points(x = betas_to_try, y = eps_10_ub[3,],col = "blue", type = "l", lty = 2)

y_axis_bounds <- c(min(min(eps_10_lb[4,]),min(p_grped_eps_10[4]))
                   ,max(max(eps_10_ub[4,]),max(p_grped_eps_10[4])))*1.1
xval = betas_to_try
which_in_bound = xval[between(p_grped_eps_10[4],eps_10_lb[4,],eps_10_ub[4,])]
plot(1,1, type = "n"
     , xlab = "Beta coeff", ylab = "eps_10 estimate", main = "eps_10 estimation sensitivity to beta - grp 3 (beta noise = 5, eps_11 = 0.7, eps_10 = 0.3)"
     , xaxt = "n"
     , xlim = c(min(betas_to_try),max(betas_to_try))
     , ylim = y_axis_bounds)
if(length(which_in_bound) > 0){
  for(j in 1:length(which_in_bound)){
    polygon(c(which_in_bound[j] - 0.05, which_in_bound[j] - 0.05, which_in_bound[j] + 0.05, which_in_bound[j] + 0.05), c(y_axis_bounds[1], y_axis_bounds[2],  y_axis_bounds[2],  y_axis_bounds[1])
            , col ="pink", border = NA)
  }
}
axis(1,at = betas_to_try,labels = betas_to_try,las = 2)
points(x = betas_to_try, y = rep(p_grped_eps_10[4],length(betas_to_try)),type = "l")
points(x = betas_to_try, y = eps_10_means[4,],col = "red", type = "l")
points(x = betas_to_try, y = eps_10_lb[4,],col = "blue", type = "l", lty = 2)
points(x = betas_to_try, y = eps_10_ub[4,],col = "blue", type = "l", lty = 2)
```

### The logBF investigation - scale and strength of signal
See the file 'sim2-0-5_waveqtl_hmt_recover_params.Rmd, and run the following chunks:

- Initialisation
- All chunks from 'New experiments - 19th July' and
